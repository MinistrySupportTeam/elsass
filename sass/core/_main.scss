// Copyright (c) 2016 Nicolas Morand (https://twitter.com/NicolasGraph)

// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// ------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

////
/// @group Main
////

// 1. MIXINS
// 1.1 elsass-group
// 1.2 elsass
// 1.3 elsass-content
// 2. FUNCTIONS
// 2.1 _elsass-bpts-set
// 2.2 _elsass-gutter-silent
// 2.3 _elsass-parse-gutter
// 2.4 _elsass-parse-behaviour
// 2.5 _elsass-parse-offset
// 2.6 _elsass-gutter-css
// 2.7 _elsass-gutter-short
// 2.8 _elsass-merge-bpt

// 1. MIXIN
// ========

// 1.1 elsass-group
// ----------------
/// Groups multiple elsass mixins to optimize the output
/// by avoiding duplicated CSS through media-queries.  
/// @content [Must contain elsass mixins and nested `elsass-content` mixins only.]
/// @example scss - SCSS
///   .foo {
///     @include elsass-group {
///       @include elsass('s', 12);
///       @include elsass('m' to 'l', 6);
///       @include elsass(from 'l', 4);
///     }
///   }
@mixin elsass-group() {
  // Parse elsass mixins.
  $elsass-config: map-merge($elsass-config, ('group': true)) !global;
  @content;
  // Wrap each breakpoint related rules in dedicated media-queries.
  @each $bpt-min, $to-map in $elsass-css {
    @each $bpt-max, $bpt-css in $to-map {
      @include _el-media($bpt-min, $bpt-max) {
        @each $prop, $val in $bpt-css {
          @if type-of($val) == map {
            @each $key, $subval in $val {
              #{$prop}: #{$subval};
            }
          } @else {
            #{$prop}: #{$val};
          }
        }
      }
    }
  }
  // Reset.
  $elsass-css: null !global;
  $elsass-config: $elsass-config-reset !global;

}

// 1.2 elsass
// ----------
/// Builds any responsive layout item.  
/// Uses global settings before to fallback to responsive ones.  
/// Muliple `elsass-mixins` should be wrap in the
/// `elsass-group` mixin to optimize the output.
/// @param {List} $media [from $ELSASS-BPT-MIN] -
///  Defines the related media-query(ies).
///   -  `'m'`: generated CSS applies to the `'m'` breakpoint;
///   - `from 'm'`: generated CSS applies to the `'m'` breakpoint and greaters;
///   - `to 'm'`: generated CSS applies to smaller breakpoints than `'m'`;
///   - .
/// @param {List} $width -
///   Defines the element `width` and (optionally) `max-witdh` from the following values.
///   - a number of columns, used as a divisor of the columns number set;
///   - a number of columns followed by ` of ` and a columns number to override de one set.
///   - `'max'`, to apply a `width` value of `100%` and a max width related to the settings.
/// @param {List | Map} $gutter -
///   Applies gutters as padding (`'in'`) and/or margin (`'out'`) based on the following valid values.  
///
///   - A map of `'in'` and/or `'out'` gutter values as:  
///     The `'out'` key can be replaced by `'silent'` to alterate the element width without 
///     - map(s) of sides related gutter ratios or `<length>`.
///       ```scss
///       $gutter: ('out': ('right': 1));
///       ```
///     - list(s) of up to four gutter ratios or `<length>` sorted in the same way
///       as the padding or margin shorthand value and where
///       any unwanted side(s) related gutter can be set to `no`;
///       ```scss
///       $gutter: ('in': 'no' .25, 'out': 'no' -.25);
///       ```
///   - A shorthand as a behaviour related keyword, optionally preceded by
///     a type related keyword to override the default one.  
///     Most behaviour related keywords accept suffixes to alterate defined gutter sides.  
///     Valid sufixes are `'-top'`, `'-right'`, `'-bottom'`, `'-left'`, `'-x'` and `'-y'`.  
///     If no suffix is provided all gutter related sides will be alterate.
///     ```scss
///     $gutter: 'all-over'; // or
///     $gutter: 'nest'; // or
///     $gutter: 'all-over' 'nest';
///     ```
///     - using the default value:
///       - `'default'`: gutter applied according to the settings;
///     - using neither margins or paddings:
///       - `'none'`: no margins or gutters applied;
///     - using margins:  
///       - types:
///         - See `elsass-advanced.gutter`;
///       - behaviours:
///         - See `elsass-advanced.behaviour`;
///
/// @param {List} $offset -
///   Container width ratio to push or pull (if negative) the element,
///   optionally followed by true to pull or push next items.
///   - A map of `'in'` and/or `'out'` offset values as:
///     - a map of sides related gutter ratios or `<length>`;
///       ```scss
///       $offset: ('out': ('left': 3));
///       ```
///     - a list of up to four gutter ratios or `<length>` sorted in the same way
///       as the padding or margin shorthand value and where
///       any unwanted side(s) related gutter can be set to `no`;
///   - A shorthand
///       ```scss
///       $gutter: 'before' 3;
///       ```
///     - using `paddings:
///       - `'before'` followed by a number: width related padding on the left;
///       - `'after'` followed by a number: width related padding on the right;
///       - `'pull'`: `'auto'` as the `margin-right` value;
///       - `'push'`: `'auto'` as the `margin-left` value;
///       - `'center'`: `'auto'` as the right and left margins;
///     - using margins:
///       - `'start'` followed by a number: width related padding on the left;
///       - `'end'` followed by a number: width related padding on the right.
/// @content [Provide @content via elsass-content mixin only.]
/// @output Arguments and and `@content` relative CSS wrapped into tidy media-queries.
/// @example scss - SCSS
///   .foo {
///     @include elsass('s' to 'l', 3);
///   }
/// @example css - CSS output
///   /* Assuming $elsass is untouched. */
///   @media screen and (max-width: 639px) {
///     .foo {
///       width: calc(25% - 24px);
///       margin: 12px;
///     }
///   }
///   @media screen and (max-width: 1023px) {
///     .foo {
///       box-sizing: border-box;
///     }
///   }
///   @media screen and (min-width: 640px) and (max-width: 1023px) {
///     .foo {
///       width: calc(25% - 32px);
///       margin: 16px;
///     }
///   }
@mixin elsass(
  $media : 'from' $ELSASS-BPT-MIN,
  $width : null,
  $gutter: null,
  $offset: null
) {

  @if $width and not $gutter {
    $gutter: $ELSASS-GUTTER;
  }

  // Get the provided breakpoints.
  $media: _elsass-parse-media($media);
  $elsass-config: map-merge($elsass-config, $media) !global;
  $bpts-set: _elsass-bpts-set($media...);
  $elsass-config: map-merge($elsass-config, ('bpts': $bpts-set)) !global;

  $max-width: false;

  @if type-of($width) == list {
    $elsass-config: map-merge($elsass-config, ('cols': nth($width, 3))) !global;
    $width: nth($width, 1);
  } @else if $width == 'max' {
    $max-width: true;
    $width: 100%;
  }

  $gutter-in: null;
  $gutter-out: null;
  $silent: null;
  $gutter-width: false;

  @if $gutter {
    $gutters: if($gutter == 'none', (), _elsass-parse-gutter($gutter));
    @if map-has-key($gutters, 'in') {
      $gutter-in: map-get($gutters, 'in');
    }
    @if map-has-key($gutters, 'out') {
      $gutter-out: map-get($gutters, 'out');
    } @else {
      $silent: true;
      $gutter-out: map-get($gutters, 'silent');
    }

    @if $gutter-out {
      @each $val in (map-get($gutter-out, 'right'), map-get($gutter-out, 'left')) {
        @if $val {
          $gutter-width: if($gutter-width, append($gutter-width, $val), $val);
          $elsass-config: map-merge($elsass-config, ('g-width': $gutter-width)) !global;
        }
      }
    }
  }

  $offset-in: null;
  $offset-out: null;

  @if $offset {
    $offsets: _elsass-parse-offset($offset);
    @if map-has-key($offsets, 'out') {
      $offset-out: map-get($offsets, 'out');
    }
    @if map-has-key($offsets, 'in') {
      $offset-in: map-get($offsets, 'in');
    }
  }

  $out: null;

  // Get and store each breakpoint related CSS.
  @each $bpt in $bpts-set {

    $elsass-config: map-merge($elsass-config, ('bpt': $bpt)) !global;

    $bpt-css: () !global;

    @if $width {
      @if $gutter-out or $gutter-in {
        $bpt-css: map-merge($bpt-css, (box-sizing: border-box)) !global;
      }
      $val: elsass-width($width, if($gutter-width, $gutter-width, false));
      $bpt-css: map-merge($bpt-css, (width: $val)) !global;
    }

    @if $max-width {
      $val: if($ELSASS-MAX-WIDTH, 'max', $bpt);
      $val: elsass-width($val, if($gutter-width, $gutter-width, false));
      $bpt-css: map-merge($bpt-css, (max-width: $val)) !global;
    }

    @if $gutter-in or $offset-in {
      $bpt-gutter: _elsass-gutter-css($gutter-in, false, $offset-in);
      @if map-has-key($bpt-gutter, 'shorthand') {
        $shorthand: map-get($bpt-gutter, 'shorthand');
        $bpt-css: map-merge($bpt-css, (padding: $shorthand)) !global;
      } @else {
        @each $side, $val in $bpt-gutter {
          $bpt-css: map-merge($bpt-css, (padding-#{$side}: $val)) !global;
        }
      }
    }

    @if $gutter-out or $offset-out {
      $bpt-gutter: _elsass-gutter-css($gutter-out, $silent, $offset-out);
      @if map-has-key($bpt-gutter, 'shorthand') {
        $shorthand: map-get($bpt-gutter, 'shorthand');
        $bpt-css: map-merge($bpt-css, (margin: $shorthand)) !global;
      } @else {
        @each $side, $val in $bpt-gutter {
          $bpt-css: map-merge($bpt-css, (margin-#{$side}: $val)) !global;
        }
      }
    }
    @content;

    // Prepare the output.
    $bpt-next: false;
    $i: index($bpts-set, $bpt);

    @if $i == length($bpts-set) {
      @if map-get($media, 'to') {
        $bpt-next: nth($ELSASS-BPTS, index($ELSASS-BPTS, $bpt) + 1);
      }
    } @else {
      $bpt-next: nth($bpts-set, $i + 1);
    }

    $bpt-out: ($bpt: ($bpt-next: $bpt-css));
    $elsass-css: if($elsass-css, _elsass-merge-bpt($elsass-css, $bpt-out), $bpt-out) !global;
  }

  // Conditional output.
  @if not map-get($elsass-config, 'group') {
    @include elsass-group; 
    $elsass-config: $elsass-config-reset !global;

  }


}

// 1.3 elsass-content
// ------------------
/// Allows to provide extra CSS that can be parsed in `elsass` mixins.
/// @param {Map} $css
///   Map of extra CSS to apply.  
///   Use a values lis
/// @example scss -
///   @include elsass(from 's') {
///     @include elsass-content((
///       border-width: elsass-gutter(),
///       color: (blue) (rgba(100, 100, 200, 0.5))
///     ));
///   }
@mixin elsass-content($css) {
  @each $property, $value in $css {
    $bpt-css: map-merge($bpt-css, ($property: $value)) !global;
  }
}

// 2. FUNCTIONS
// ============

// 2.1 _elsass-bpts-set
// --------------------
/// Get a list of breakpoints
/// explicitly and implicitly set.
/// @param {Breakpoint} $from;
/// @param {Breakpoint} $to;
/// @return {List | false} Breakpoints list | false;
/// @example scss -
///   _elsass-bpts-set('s', 'l')
///   // Assuming valid bpts are 's', 'm', 'l' and 'xl';
///   // 's' 'm' 'l'
@function _elsass-bpts-set($from: null, $to: null) {
  $out: false;
  $i-from: if($from, index($ELSASS-BPTS, $from), 1);
  $i-to: if($to, index($ELSASS-BPTS, $to), length($ELSASS-BPTS));

  @for $i from $i-from through $i-to {
    @if not $to or $i != index($ELSASS-BPTS, $to) {
      $bpt: nth($ELSASS-BPTS, $i);
      $out: if($out, append($out, $bpt), $bpt);
    }
  }

  @return $out;
}

// 2.2 _elsass-gutter-silent
// -------------------------
/// Returns a map of needed flex related
/// CSS properties and their values.
/// @param {…} $gutter CSS flex-wrap value;
/// @return {List | false} Silent gutter value | false.
@function _elsass-gutter-silent($gutter: null) {
  $out: false;

  @if $gutter == 'silent' {
    $out: $ELSASS-GUTTER;
  } @else if type-of($gutter) == map and map-has-key($gutter, 'silent') {
    $out: map-get($gutter, 'silent');
  }

  @return $out;
}

// 2.3 _elsass-parse-gutter
// ----------------------
/// Return a map of side values from the elsass mixin $gutter value.
/// @param {List} $gap -
///   Single value or list of two or four values;
/// @return {Map | false} Map of side values | false.
/// @example scss -
///   _elsass-parse-gutter(false .5);
///   // (top: false, left: .5, bottom: false, $right: .5)
@function _elsass-parse-gutter($gutter: null) {
  $silent: null;
  $behaviour: null;

  // Parse keywords.
  @if type-of($gutter) == string or type-of($gutter) == list {
    $type: nth($gutter, 1);

    @if not map-has-key($ELSASS-GUTTERS, $type) {
      $behaviour: $type;
      $type: $ELSASS-GUTTER;
    } @else {
      @if length($gutter) == 2 {
        $behaviour: nth($gutter, 2);
      }
      @if $type == 'default' {
        $type: $ELSASS-GUTTER;
      }
    }

    // Assign values according to $type.
    @if type-of($type) == string {
      $gutter: map-get(map-get($elsass-advanced, 'gutter'), $type);
    } @else {
      $gutter: $type;
    }
  }

  // Get gutters map.
  $out: false;

  @each $pos, $vals in $gutter {

    @if not $silent and $pos == 'out' and _elsass-gutter-silent($vals) {
      $silent: true;
      $vals: _elsass-gutter-silent($vals);
    }

    // Get a four values list from one to four values.
    @if type-of($vals) == number {
      $vals: $vals $vals $vals $vals;
    } @else if type-of($vals) == list {
      @if length($vals) == 2 {
        $vals: nth($vals, 1) nth($vals, 2) nth($vals, 1) nth($vals, 2);
      } @else if length($vals) == 3 {
        $vals: nth($vals, 1) nth($vals, 2) nth($vals, 3) nth($vals, 2);
      }
    }

    // Get a map of sides values.
    @if type-of($vals) == list {
      @each $side in $ELSASS-SIDES {
        $i: index($ELSASS-SIDES, $side);
        $val: nth($vals, $i);
        @if type-of($val) == number {
          $merge: ($side: $val);
          @if $out {
            @if map-has-key($out, $pos) {
              $out: map-merge($out, ($pos: map-merge(map-get($out, $pos), $merge)));
            } @else {
              $out: map-merge($out, ($pos: $merge));
            }
          } @else {
            $out: ($pos: $merge);
          }
        }
      }
    } @else {
      $out: ($pos: $vals);
    }
  }

  // Alterate gutters according $behaviour.
  @if $out and $behaviour {
    $out: _elsass-parse-behaviour($out, $behaviour);
  }

  @return $out;
}

// 2.4 _elsass-parse-behaviour
// ---------------------------
/// Alterate a map of sides related gutter values
/// according to a define behaviour.
/// @param {Map} $gutter -
///   Map of sides related gutter values;
/// @param {String} $behaviour -
///   Behaviour related keyword;
/// @return {Map} New map of sides related gutter values.
@function _elsass-parse-behaviour($gutter, $behaviour) {
  $out: $gutter;
  $new: null;

  $dash: str_index($behaviour, '-');
  $kw: $behaviour;
  $sides: $ELSASS-SIDES;
  
  @if $dash {
    $sides: str_slice(#{$kw}, $dash + 1);
    @if $sides == 'x' {
      $sides: 'right' 'left';
    } @else if $sides == 'y' {
      $sides: 'top' 'bottom';
    }
    $kw: str_slice(#{$kw}, 1, $dash - 1);
  }

  $gutter-pos: 'out';

  @if map-has-key($gutter, 'in') and map-has-key($gutter, 'out') {
    $gutter-pos: 'in-out';
  } @else if map-has-key($gutter, 'in') {
    $gutter-pos: 'in';
  }

  $to: map-get(map-get($ELSASS-BEHAVIOURS, $gutter-pos), $kw);

  // Alterate values.
  @if $to == 'silent' {
    $out: ('silent': map-get($gutter, 'out'));
  } @else {
    @each $pos, $vals in $to {
      $map: ();
      @each $side in $sides {
        $map: map-merge($map, ($side: $vals));
      }
      $vals: $map;

      $new: ();

      @each $side, $val in $vals {
        $from: null;
        $base: null;
        $alt: $val;
        @if type-of($val) == list {
          $from: nth($val, 1);
          $alt: nth($val, 2);
          @if map-has-key($gutter, $from) and (map-has-key(map-get($gutter, $from), $side)) {
            $base: map-get(map-get($gutter, $from), $side);
            $new: map-merge($new, ($side: $base * $alt));
          }
        } @else {
          @if map-has-key($gutter, $pos) and (map-has-key(map-get($gutter, $pos), $side)) {
            @if $val == 'no' {
              $gutter: map-merge($gutter, ($pos: map-remove(map-get($gutter, $pos), $side)));
            } @else {
              $new: map-merge($new, ($side: $alt));
            }
          }
        }
      }
      $merge: if(map-has-key($gutter, $pos), map-get($gutter, $pos), null);
      $alt: ($pos: if($merge, map-merge(map-get($gutter, $pos), $new), $new));
      $out: if($out, map-merge($out, $alt), $alt);
    }
    $out: map-merge($gutter, $out);
  }

  @return $out;
}

// 2.5 _elsass-parse-offset
// ---------------------
/// Returns a map of needed flex related
/// CSS properties and their values.
/// @access  Private
/// @param {Map | List} $offset;
/// @return {Map | false} Map of offset value(s) per side | false.
@function _elsass-parse-offset($offset: null) {
  $out: false;

  @if type-of($offset) == map {
    @each $pos, $vals in $offset {
      @if type-of($vals) == number {
        $vals: $vals $vals;
      }
      @if type-of($vals) == list {
        @each $side in ('left', 'right') {
          $i: index(('left', 'right'), $side);
          $val: nth($vals, $i);
          @if $val {
            @if $out {
              @if map-has-key($out, $pos) {
                $pos: ($pos: map-merge(map-get($out, $pos), ($side: $val)));
                $out: map-merge($out, $pos);
              } @else {
                $out: map-merge($out, ($pos: ($side: $val)));
              }
            } @else {
              $out: ($pos: ($side: $val));
            }
          }
        }
      } @else {
        $out: $offset;
      }
    }
  } @else {
    // Parse keywords.
    $new: null;

    $i: 1;
    @while $i <= length($offset) {
      $kw: nth($offset, $i);
      $val: null;

      @if $i < length($offset) and type-of(nth($offset, $i + 1)) == number {
        $val: nth($offset, $i + 1);
        $i: $i + 2;
      } @else {
        $val: auto;
        $i: $i + 1;
      }

      $pos: nth(map-keys(map-get($ELSASS-OFFSETS, $kw)), 1);
      @if $new and not map-has-key($new, $pos) {
        $new: map-merge($new, ($pos: null));
      } @else if not $new {
        $new: ($pos: null);
      }

      @each $side in map-get(map-get($ELSASS-OFFSETS, $kw), $pos) { 
        @if map-get($new, $pos) {
          $new: map-merge($new, ($pos: map-merge(map-get($new, $pos), ($side: $val))));
        } @else {
          $new: map-merge($new, ($pos: ($side: $val)));
        }
      }
    }
    $out: $new;
  }

  @return $out;
}

// 2.6 _elsass-gutter-css
// ----------------------
/// Returns a map of needed flex related
/// CSS properties and their values.
/// @param {Breakpoint | Ratio | Lentgth} $gutter
///   Breakpoint related gutter ratio(s) or CSS value(s);
/// @param {Ratio} $offset;
/// @param {Bool} $offset-next;
/// @return {Map | false} Map of side values | false.
@function _elsass-gutter-css(
  $gutter : null,
  $silent : null,
  $offset : null
) {
  $out: ();
  $shorthand: null;

  // Get a map of each margin side value.
  $vals: ();

  @each $side in $ELSASS-SIDES {
    @if not $silent or ($offset and map-has-key($offset, $side)) { 
      $off: if($offset, map-get($offset, $side), false);
      $gutter-val: if($gutter, map-get($gutter, $side), false);
      $val: null;
      @if $off == auto {
        $val: $off;
      } @else {
        $val: elsass-gutter(if($gutter-val, $gutter-val, false), $off);
      }
      $vals: map-merge($vals, ($side: $val));
    }
  }

  $shorthand: _elsass-gutter-short($vals...);

  @if $shorthand {
    $out: map-merge($out, ('shorthand': $shorthand));
  } @else {
    @each $side in $ELSASS-SIDES {
      $val: map-get($vals, $side);
      @if $val != false {
        $out: map-merge($out, (#{$side}: $val));
      }
    }
  }

  @return $out;
}

// 2.7 _elsass-gutter-short
// ------------------------
/// Returns a padding/margin shorthand value if possible.
/// @param {Number} $top - Top gutter length.
/// @param {Number} $right - Right gutter length.
/// @param {Number} $bottom - Bottom gutter length.
/// @param {Number} $left - Left gutter length.
/// @return {Number | false} Shorthand value | false.
@function _elsass-gutter-short(
  $top   : null,
  $right : null,
  $bottom: null,
  $left  : null
) {
  $out: false;

  @if $top and $top == $bottom and $right and $right == $left {
    $out: if($top == $right, $top, $top $right);
  }

  @return $out;
}

// 2.8 _elsass-merge-bpt
// ---------------------
/// Merge map of CSS stored per media-queries related
/// breakpoints in a way to optimize the outpout.
/// @param {Map} $out
///   Map of CSS stored per media-queries relative breakpoints;
/// @param {Map} $map
///   Map of the following breapoint CSS;
/// @return {Map} Map of CSS per media-queries.
/// @example scss -
///   $out: (s: (m: (width: 25%, margin: 10px)));
///   $bpt-map: (m: (l: (width: 25%, margin: 15px)));
///   elsass-merge($out, $bpt-map);
///   // (s: (m: (margin: 10px), l: (width: 25%)),
///   //  m: (l: (margin: 15px)));
@function _elsass-merge-bpt($out, $bpt-map) {
  $new-css: ();

  $bpt: nth(map-keys($bpt-map), 1);
  $submap: map-get($bpt-map, $bpt);
  $bpt-next: nth(map-keys($submap), 1);
  $bpt-css: map-get($submap, $bpt-next);

  @each $bpt-prop, $bpt-val in $bpt-css {
    @each $bpt-from, $map-to in $out {
      @if map-has-key($map-to, $bpt) {
        $to-css: map-get($map-to, $bpt);
        @if map-get($to-css, $bpt-prop) == $bpt-val {
          // Remove duplicated CSS.
          $bpt-css: map-remove($bpt-css, $bpt-prop);
          $to-css: map-remove($to-css, $bpt-prop);
          // Move duplicated CSS in an extended media-query.
          $new-css: map-merge($new-css, ($bpt-prop: $bpt-val));
          $new-map-to: ($bpt: $to-css, $bpt-next: $new-css);
          $map-to: map-merge(map-get($out, $bpt-from), $new-map-to);

          $out: map-merge($out, ($bpt-from: ($map-to)));
        }
        $out: map-merge($out, ($bpt: ($bpt-next: $bpt-css)));
      } @else {
        $out: map-merge($out, ($bpt: ($bpt-next: $bpt-css)));
      }
    }
  }

  @return $out;
}
