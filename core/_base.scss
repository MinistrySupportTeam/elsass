// Copyright (c) 2016 Nicolas Morand (https://twitter.com/NicolasGraph)

// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// ------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

////
/// @group Misc
////

// 1. CONSTANTS
// 2. MIXIN
// 2.1 elsass-media
// 2.2 _el-media
// 3. FUNCTIONS
// 3.1 el_width
// 3.2 el_gutte
// 3.3 elsass-config
// 3.4 _elsass-responsive

// 2. MIXIN
// ========

// 2.1 elsass-medi
// ----------------
/// Wrap `@content` in a media-query.
/// @param {List} $media [from $ELSASS-BPT-MIN] -
///  Defines the related media-query `min` and\or `max-width` from one
///  of the following value where each `<breakpoint>` could be a `<length>`
///  when used with `from`or `to`:
///   -  `<breakpoint>` applies to the provided breakpoint only;
///   - `from <breakpoint>` applies to the provided breakpoint and larger ones;
///   - `to <breakpoint>` applies to smaller breakpoints than the one provided;
///   - `<breakpoint> to <breakpoint>` 
/// @example scss - SCSS
///   .foo {
///     @include elsass-media(to 'm') {
///       background: #eee;
///     }
///   }
@mixin elsass-media($media) {
  $media: _elsass-parse-media($media);
  
  @include _el-media($media...) {
    @content;
  }
}

// 2.2 _el-media
// -------------
/// Wrap `@content` in a media-query.
/// @param {String | Number} $from [$ELSASS-BPT-MIN] -
///   media-query min-width related breakpoint name or `<length>`;
/// @param {String | Number} $to -
///   media-query max-width related breakpoint name or `<length>`;
@mixin _el-media($from: $ELSASS-BPT-MIN, $to: null) {
  $mq: false; // Media-query

  // Set a media-query min-width if $from is set and is not the first bpt.
  @if $from and $from != $ELSASS-BPT-MIN {
    @if index($ELSASS-BPTS, $from) {
      $from: map-get(_elsass-responsive($from), 'device-min-width');
    }
    $mq: '(min-width: #{$from})';
  }

  // Set a media-query max-width if $to is set.
  @if $to {
    @if index($ELSASS-BPTS, $to) {
      $to: map-get(_elsass-responsive($to), 'device-min-width') - 1;
    }
    $mq: if($mq, $mq ' and ', '') '(max-width: #{$to})';
  }

  // Wrap @content in a media query if set.
  @if $mq {
    @media screen and #{$mq} {
      @content;
    }
  } @else {
    @content;
  }
}

// 3. FUNCTIONS
// ============

// 3.1 elsass-parse-media
// ----------------------
/// Parse an `elsass` or `elsass-media` mixin `$media` argument value.
/// @param {List} $media [from $ELSASS-BPT-MIN] -
///  Defines the related media-query `min` and\or `max-width` from one
///  of the following value where each `<breakpoint>` could be a `<length>`
///  when used with `from`or `to`:
///   -  `<breakpoint>` applies to the provided breakpoint only;
///   - `from <breakpoint>` applies to the provided breakpoint and larger ones;
///   - `to <breakpoint>` applies to smaller breakpoints than the one provided;
///   - `<breakpoint> to <breakpoint>` 
/// @return {Map}.
@function _elsass-parse-media($media) {
  $from: $ELSASS-BPT-MIN;
  $to: null;

  @if index($ELSASS-BPTS, $media) {
    $from: $media;
    $i: index($ELSASS-BPTS, $media);
    @if $i != length($ELSASS-BPTS) {
      $to: nth($ELSASS-BPTS, index($ELSASS-BPTS, $media) + 1);
    }
  } @else if type-of($media) == list {
    @if length($media) == 2 {
      @if nth($media, 1) == 'from' {
        $from: nth($media, 2);
        $to: false;
      } @else {
        $from: nth($ELSASS-BPTS, 1);
        $to: nth($media, 2);
      }
    } @else if length($media) == 3 {
      $from: nth($media, 1);
      $to: nth($media, 3);
    }
  }

  @return if($to, ('from': $from, 'to': $to), ('from': $from));
}

// 3.1 elsass-width
// ----------------
/// Calculate width by substracting potential
/// right and left gutters used as margin.
/// @param {Number | String} $width -
///   Defines the length base.
///   - `<number>` defines a default columns number fraction;
///   - `<number> of <number>` defines a custom columns number fraction;
///   - `max` uses the global container max-width set.
///   - `<breakpoint>` uses the breakpoint related container max-width set.
/// @param {Number | List | Map} $gutter-width -
///   Defines the margin length to substract from one of the following value.
///   - a sum or list of the right and left gutter ratios or lengths; 
///   - a map using a breakpoint as key and a sum or list of the right and left gutter ratios or lengths as value.
///   - a breakpoint name (uses the related gutter lentgh); 
/// @return {Number} `<length>` (via `calc()` if needed).
/// @example scss - SCSS
///   width: elsass-width(12, 'm');
///   max-width: elsass-width('m', 'm');
@function elsass-width(
  $width: null,
  $gutter-width: _elsass-config('g-width')
) {

  $max: null;
  
  @if $ELSASS-MAX-WIDTH {
    $max: $ELSASS-MAX-WIDTH;
  } @else if _elsass-config('bpt') {
    $max: map-get(_elsass-responsive(_elsass-config('bpt')), 'container-max-width');
  }

  $cols: if(_elsass-config('cols'), _elsass-config('cols'), $ELSASS-COLS);

  // Parse $width.
  @if type-of($width) == number and unitless($width) {
    $width: percentage($width / $cols);
  } @else if $width == 'max' and $max {
    $width: $max;
  } @else if index($ELSASS-BPTS, $width) {
    $width: map-get(_elsass-responsive($width), 'container-max-width');
  } @else if type-of($width) == list {
    @if length($width) == 3 {
      $width: percentage(nth($width, 1) / nth($width, 3));
    } @else if length($width) == 2 {
      $width: $max * (nth($width, 1) / $cols);
    } @else if  length($width) == 4 {
      $width: $max * (nth($width, 1) / nth($width, 4));
    }
  }

  $calc: null;

  @if $gutter-width {
    $bpt: null;

    // Parse $gutter-width;
    @if type-of($gutter-width) == number and unitless($gutter-width) {
      @if $ELSASS-GUTTER-LENGTH {
        $gutter-width: $gutter-width * $ELSASS-GUTTER-LENGTH;
      } @else {
        $bpt: _elsass-config('bpt');
      }
    } @else if type-of($gutter-width) == map {
      $bpt: nth(map-keys($gutter-width), 1);
      $gutter-width: map-get($gutter-width, $bpt);
    }

    // Get a margin value to subtract.
    @each $gutter in $gutter-width {
      $val: elsass-gutter(if($bpt, ($bpt: $gutter), $gutter));
      @if $calc and comparable($calc, $val) {
        $calc: $calc + $val;
      } @else {
        $calc: if($calc, append($calc, $val), $val);
      }
    }

    $gutter-width: $calc;
    $calc: null;
    
    // Calculate width according to margins.
    @each $val in $gutter-width {
      $abs: abs($val);
      @if comparable($width, $val) {
        $width: if($val == $abs, $width - $abs, $width + $abs);
      } @else {
        $operator: if($val == $abs, '-', '+');
        @if $calc {
          $calc: append($calc, #{$operator} #{$abs});
        } @else {
          $calc: #{$operator} #{$abs};
        }
      }
    }
  }

  @return if($calc, calc(#{$width} #{$calc}), $width);
}

// 3.2 elsass-gutter
// -----------------
/// Calculate a gutter length.
/// @param {Number | String | Map} $gutter -
///   Defines a gutter length.
///   - a global gutter length ratio;
///   - a breakpoint related gutter length ratio
///     as the value of a map using the breakpoint as key;
///   - a breakpoint name as a shorthand of `(breakpoint: 1)`.
/// @param {Number | Length} $offset -
///   Number of columns or `<length>`.
///   - `n` defines a default columns number fraction;
///   - `n of n` defines a custom columns number fraction.
/// @return {Number} `<length>`
/// @example scss - SCSS
///   margin-right: elsass-gutter(('m': 0.5));
///   margin-left: elsass-gutter(('m': 0.5), 3);
@function elsass-gutter(
  $gutter: _elsass-config('g-width'),
  $offset: null
) {

  @if $gutter {
    // Parse gutter.
    @if type-of($gutter) == number and unitless($gutter) {
      @if $ELSASS-GUTTER-LENGTH {
        $gutter: $gutter * $ELSASS-GUTTER-LENGTH;
      } @else {
        $gutter: $gutter * map-get(_elsass-responsive(_elsass-config('bpt')), 'gutter-length');
      }
   } @else if type-of($gutter) == map {
      $bpt: nth(map-keys($gutter), 1);
      $gutter-length: map-get(_elsass-responsive($bpt), 'gutter-length');
      $gutter: map-get($gutter, $bpt) * $gutter-length;
    } @else if index($ELSASS-BPTS, $gutter) {
      $gutter: map-get(_elsass-responsive($gutter), 'gutter-length');
    }
  }

  @if $offset {
    // Parse $offset.
    @if type-of($offset) == number {
      $cols: if(_elsass-config('cols'), _elsass-config('cols'), $ELSASS-COLS);
      $offset: if(unitless($offset), percentage($offset / $cols), $offset);
    } @else if type-of($offset) == list {
      $offset: percentage(nth($offset, 1) / nth($offset, 3));
    }

    @if $gutter {
      // Reset $gutter.
      $abs: abs($offset);
      @if comparable($gutter, $abs) {
        $gutter: if($offset == $abs, $gutter + $abs, $gutter - $abs);
      } @else {
        @if $offset == $abs {
          $gutter: calc(#{$gutter} + #{$abs});
        } @else {
          $gutter: calc(#{$gutter} - #{$abs});
        }
      }
    }
  }

  @return if($gutter, $gutter, $offset);
}

// 3.3 elsass-config
// -----------------
/// Get an `$elsass-config` key value.
/// @param {String} $key/// @param {Number | Length} $offset -
/// @return {<value>} `$elsass-config` key value.
@function _elsass-config($key) {
  $out: false;

  @if map-has-key($elsass-config, $key) {
    $out: map-get($elsass-config, $key);
  }

  @return $out;
}

// 3.4 _elsass-responsive
// ----------------------
/// Get an `$elsass-responsive` key value.
/// @param {String} $key/// @param {Number | Length} $offset -
/// @return {<value>} `$elsass-responsive` key value.
@function _elsass-responsive($key) {
  $out: false;

  @if map-has-key($elsass-responsive, $key) {
    $out: map-get($elsass-responsive, $key);
  }

  @return $out;
}
