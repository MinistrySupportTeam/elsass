// Copyright (c) 2016 Nicolas Morand (https://twitter.com/NicolasGraph)

// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// ------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

////
/// @group Misc
////

// 1. CONSTANTS
// 2. MIXIN
// 2.1 elsass-media
// 2.2 _elsass-media
// 3. FUNCTIONS
// 3.1 el_width
// 3.2 el_gutter
// 3.3 _elsass-map-get
// 3.4 elsass-config
// 3.5 _elsass-responsive
// 3.6 _elsass-setting
// 3.7 _elsass-map-merge

// 2. MIXIN
// ========

// 2.1 elsass-media
// ----------------
/// Wrap `@content` in a media-query.
/// @param {List} $media [from $ELSASS-BPT-MIN] -
///  Defines the related media-query `min` and\or `max-width` from one
///  of the following value where each `<breakpoint>` could be a `<length>`
///  when used with `from`or `to`:
///   -  `<breakpoint>` applies to the provided breakpoint only;
///   - `from <breakpoint>` applies to the provided breakpoint and larger ones;
///   - `to <breakpoint>` applies to smaller breakpoints than the one provided;
///   - `<breakpoint> to <breakpoint>` 
/// @example scss - SCSS
///   .foo {
///     @include elsass-media(to 'm') {
///       background: #eee;
///     }
///   }
@mixin elsass-media($media) {
  $media: _elsass-parse-media($media);
  
  @include _elsass-media($media...) {
    @content;
  }
}

// 2.2 _elsass-media
// -------------
/// Wrap `@content` in a media-query.
/// @param {String | Number} $from [$ELSASS-BPT-MIN] -
///   media-query min-width related breakpoint name or `<length>`;
/// @param {String | Number} $to -
///   media-query max-width related breakpoint name or `<length>`;
@mixin _elsass-media($from: $ELSASS-BPT-MIN, $to: null) {
  $mq: false; // Media-query

  // Set a media-query min-width if $from is set and is not the first bpt.
  @if $from and $from != $ELSASS-BPT-MIN {
    @if _elsass-responsive($from) {
      $from: _elsass-responsive($from, 'device-min-width');
    }
    $mq: '(min-width: #{$from})';
  }

  // Set a media-query max-width if $to is set.
  @if $to {
    @if _elsass-responsive($to) {
      $to: _elsass-responsive($to, 'device-min-width') - 1;
    }
    $mq: if($mq, $mq ' and ', '') '(max-width: #{$to})';
  }

  // Wrap @content in a media query if set.
  @if $mq {
    @media screen and #{$mq} {
      @content;
    }
  } @else {
    @content;
  }
}

// 3. FUNCTIONS
// ============

// 3.1 elsass-parse-media
// ----------------------
/// Parse an `elsass` or `elsass-media` mixin `$media` argument value.
/// @param {List} $media [from $ELSASS-BPT-MIN] -
///  Defines the related media-query `min` and\or `max-width` from one
///  of the following value where each `<breakpoint>` could be a `<length>`
///  when used with `from`or `to`:
///   -  `<breakpoint>` applies to the provided breakpoint only;
///   - `from <breakpoint>` applies to the provided breakpoint and larger ones;
///   - `to <breakpoint>` applies to smaller breakpoints than the one provided;
///   - `<breakpoint> to <breakpoint>` 
/// @return {Map}.
@function _elsass-parse-media($media) {
  $from: $ELSASS-BPT-MIN;
  $to: null;

  @if _elsass-responsive($media) {
    $from: $media;
    $i: index($ELSASS-BPTS, $media);
    @if $i != length($ELSASS-BPTS) {
      $to: nth($ELSASS-BPTS, index($ELSASS-BPTS, $media) + 1);
    }
  } @else if type-of($media) == list {
    @if length($media) == 2 {
      @if nth($media, 1) == 'from' {
        $from: nth($media, 2);
        $to: false;
      } @else {
        $from: nth($ELSASS-BPTS, 1);
        $to: nth($media, 2);
      }
    } @else if length($media) == 3 {
      $from: nth($media, 1);
      $to: nth($media, 3);
    }
  }

  @return if($to, ('from': $from, 'to': $to), ('from': $from));
}

// 3.1 elsass-width
// ----------------
/// Calculate width by substracting potential
/// right and left gutters used as margin.
/// @param {Number | String} $width -
///   Defines the length base.
///   - `<number>` defines a default columns number fraction;
///   - `<number> of <number>` defines a custom columns number fraction;
///   - `max` uses the global container max-width set.
///   - `<breakpoint>` uses the breakpoint related container max-width set.
/// @param {Number | List | Map} $gutter-width -
///   Defines the margin length to substract from one of the following value.
///   - a sum or list of the right and left gutter ratios or lengths; 
///   - a map using a breakpoint as key and a sum or list of the right and left gutter ratios or lengths as value.
///   - a breakpoint name (uses the related gutter lentgh); 
/// @return {Number} `<length>` (via `calc()` if needed).
/// @example scss - SCSS
///   width: elsass-width(12, 'm');
///   max-width: elsass-width('m', 'm');
@function elsass-width(
  $width: null,
  $gutter-width: _elsass-config('g-width')
) {
  
  $max: _elsass-setting('container-max-width', _elsass-config('bpt'));

  $cols: if(_elsass-config('cols'), _elsass-config('cols'), _elsass-setting('columns'));

  // Parse $width.
  @if type-of($width) == number and unitless($width) {
    $width: percentage($width / $cols);
  } @else if $width == 'max' and $max {
    $width: $max;
  } @else if _elsass-responsive($width) {
    $width: _elsass-responsive($width, 'container-max-width');
  } @else if type-of($width) == list {
    @if length($width) == 3 {
      $width: percentage(nth($width, 1) / nth($width, 3));
    } @else if length($width) == 2 {
      $width: $max * (nth($width, 1) / $cols);
    } @else if  length($width) == 4 {
      $width: $max * (nth($width, 1) / nth($width, 4));
    }
  }

  $calc: null;

  @if $gutter-width {
    $bpt: null;

    // Parse $gutter-width;
    @if type-of($gutter-width) == number and unitless($gutter-width) {
      @if _elsass-setting('gutter-length') {
        $gutter-width: $gutter-width * _elsass-setting('gutter-length');
      } @else {
        $bpt: _elsass-config('bpt');
      }
    } @else if type-of($gutter-width) == map {
      $bpt: nth(map-keys($gutter-width), 1);
      $gutter-width: map-get($gutter-width, $bpt);
    }

    // Get a margin value to subtract.
    @each $gutter in $gutter-width {
      $val: elsass-gutter(if($bpt, ($bpt: $gutter), $gutter));
      @if $calc and comparable($calc, $val) {
        $calc: $calc + $val;
      } @else {
        $calc: if($calc, append($calc, $val), $val);
      }
    }

    $gutter-width: $calc;
    $calc: null;
    
    // Calculate width according to margins.
    @each $val in $gutter-width {
      $abs: abs($val);
      @if comparable($width, $val) {
        $width: if($val == $abs, $width - $abs, $width + $abs);
      } @else {
        $operator: if($val == $abs, '-', '+');
        @if $calc {
          $calc: append($calc, #{$operator} #{$abs});
        } @else {
          $calc: #{$operator} #{$abs};
        }
      }
    }
  }

  @return if($calc, calc(#{$width} #{$calc}), $width);
}

// 3.2 elsass-gutter
// -----------------
/// Calculate a gutter length.
/// @param {Number | String | Map} $gutter -
///   Defines a gutter length.
///   - a global gutter length ratio;
///   - a breakpoint related gutter length ratio
///     as the value of a map using the breakpoint as key;
///   - a breakpoint name as a shorthand of `(breakpoint: 1)`.
/// @param {Number | Length} $offset -
///   Number of columns or `<length>`.
///   - `n` defines a default columns number fraction;
///   - `n of n` defines a custom columns number fraction.
/// @return {Number} `<length>`
/// @example scss - SCSS
///   margin-right: elsass-gutter(('m': 0.5));
///   margin-left: elsass-gutter(('m': 0.5), 3);
@function elsass-gutter(
  $gutter: _elsass-config('g-width'),
  $offset: null
) {

  @if $gutter {
    // Parse gutter.
    @if type-of($gutter) == number and unitless($gutter) {
      $gutter: $gutter * _elsass-setting('gutter-length', _elsass-config('bpt'));
   } @else if type-of($gutter) == map {
      $bpt: nth(map-keys($gutter), 1);
      $gutter-length: _elsass-responsive($bpt, 'gutter-length');
      $gutter: map-get($gutter, $bpt) * $gutter-length;
    } @else if _elsass-responsive($gutter) {
      $gutter: _elsass-responsive($gutter, 'gutter-length');
    }
  }

  @if $offset {
    // Parse $offset.
    @if type-of($offset) == number {
      $cols: if(_elsass-config('cols'), _elsass-config('cols'), _elsass-setting('columns'));
      $offset: if(unitless($offset), percentage($offset / $cols), $offset);
    } @else if type-of($offset) == list {
      $offset: percentage(nth($offset, 1) / nth($offset, 3));
    }

    @if $gutter {
      // Reset $gutter.
      $abs: abs($offset);
      @if comparable($gutter, $abs) {
        $gutter: if($offset == $abs, $gutter + $abs, $gutter - $abs);
      } @else {
        @if $offset == $abs {
          $gutter: calc(#{$gutter} + #{$abs});
        } @else {
          $gutter: calc(#{$gutter} - #{$abs});
        }
      }
    }
  }

  @return if($gutter, $gutter, $offset);
}

// 3.3 _elsass-map-get
// -------------------
/// Get a map key/subkey value.
/// @param {Map} $map
/// @param {String} $key
/// @param {String} $subkey -
///   `$key` key if `$key` value is a map. 
/// @return {<value>} `$map` breakpoint related key/subkey value.
@function _elsass-map-get($map, $key, $subkey: null) {
  $out: false;

  @if map-has-key($map, $key) {
    @if $subkey {
      $submap: map-get($map, $key);
      @if map-has-key($submap, $subkey) {
        $out: map-get($submap, $subkey);
      }
    } @else {
      $out: map-get($map, $key);
    }
  }

  @return $out;
}

// 3.4 _elsass-config
// ------------------
/// Get an `$elsass-config` value.
/// @param {String} $key -
///   `elsass-config` key.
/// @return {<value>} `$elsass-config` key related value.
@function _elsass-config($key) {  
  @return _elsass-map-get($elsass-config, $key);
}

// 3.5 _elsass-responsive
// ----------------------
/// Get an `$elsass-responsive` key value.
/// @param {String} $bpt
/// @param {String} $key
/// @return {<value>} `$elsass-responsive` breakpoint related key value.
@function _elsass-responsive($bpt, $key: null) {  
  @return _elsass-map-get($elsass-responsive, $bpt, $key);
}

// 3.6 _elsass-setting
// -------------------
/// Get an `$elsass-global` value and fallback
/// to an `$elsass-responsive` breakpoint related one
/// if `$bpt` is defined.
/// @param {String} $setting -
///   `$elsass-global` key or `$elsass-responsive` breakpoint related key.
/// @param {String} $bpt -
///   Used to fallback to the right breakpoint settings
///   in `$elsass-responsive` if needed.
/// @return {<value>} `$elsass-global` or `$elsass-responsive` key value.
@function _elsass-setting($setting, $bpt: null) {
  $out: null;

  @if $bpt { 
    $out: _elsass-map-get($elsass-responsive, $bpt, $setting);
  } @else {
    $out: _elsass-map-get($elsass-global, $setting);
  }
  
  @return $out;
}

// 3.7 _elsass-map-merge
// ---------------------
/// Merge maps/maps keys.
/// @param {Map|List} $map1 -
///   Map or list of a map and one of
///   its key which value is also a map.
/// @param {Map|List} $map2
///   Map or list of a map and one of
///   its key which value is also a map.
/// @return {Map} Merged map.
@function _elsass-map-merge($map1, $map2) {

  @if type-of($map1) == list and length($map1) == 2 {
    $map1: map-get(nth($map1, 1), nth($map1, 2));
  }

  @if type-of($map2) == list and length($map2) == 2 {
    $map2: map-get(nth($map2, 1), nth($map2, 2));
  }

  @return map-merge($map1, $map2);
}

// 3.8 _elsass-error
// ---------------------
/// Throws an error message.
/// @param {string} $error -
///   Main error message.
/// @param {string} $clue
///   About where something went wrong.
/// @param {string} $fix
///   About how to fix.
@function _elsass-error($error, $clue: null, $fix: null) {

  @error '#{$error} #{$clue}
#{$fix}';

}
