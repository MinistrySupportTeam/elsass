// Copyright (c) 2016 Nicolas Morand (https://twitter.com/NicolasGraph)

// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// ------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// 1.   Settings
// 1.1  Default mixin argument values
// 2.   Mixins (underscore for nested mixin)
// 2.1  elsass
// 3.   Functions (underscore for nested functions)
// 3.1  elsass
// 3.2  _elsass-shift-map
// 3.3  _elsass-gutter-short
// 3.4  _elsass-bpts-set

// 1. Settings
// ===========

// 1.1 Default mixin argument values
// ---------------------------------
$elsass-settings: (
  'media'     : $BPT-MIN,
  'width'     : 1 true,
  'gutter-in' : 0.5,
  'gutter-out': 0.5,
  'shift'     : null,
) !default;

// 2. Mixin
// ========

// 2.1 elsass
// ----------
// Wrap CSS content and arguments related CSS in media-queries.
// @param  $media       Breakpoint(s);
// @param  $width       Ratio(s) or CSS width and max width value(s);
// @param  $gutter-in   Ratio(s) of the breakpoint gutter or CSS padding value(s);
// @param  $gutter-out  Ratio(s) of the breakpoint gutter or CSS margin value(s);
// @param  $shift       'pull', 'push', 'center' or ratio of the container width
//                      optionally followed by true to pull or push next items.

@mixin elsass(
  $media     : null,
  $width     : null,
  $gutter-in : null,
  $gutter-out: null,
  $shift     : null
) {

  // Set arguments to their default values if needed.
  $args: (
    'media'     : $media,
    'width'     : $width,
    'gutter-in' : $gutter-in,
    'gutter-out': $gutter-out,
    'shift'     : $shift,
  );

  $default: false;

  @each $arg, $val in $args {
    @if ($val == true or $val == '…') or ($val == null and $default) {
      $args: map-merge($args, ($arg: map-get($elsass-settings, $arg)));
      @if not $default and $val == '…' {
        $default: true;
      }
    }
  }

  // Get the provided breakpoints.
  $media: map-get($args, 'media');
  $from: if(nth($media, 1), nth($media, 1), $BPT-MIN);
  $to: if(type-of($media) == list, nth($media, 2), false);

  // Wrap each breakpoint related rules in dedicated media-queries.
  @if map-remove($args, 'media') != () {
    $css: elsass($args...);
    $content: false;

    @if not (map-has-key($css, $from) and
        map-has-key(map-get($css, $from), $to)) {
      // Wrap content in a dedicated media-query.
      @include elsass-media($from, $to) {
        @content;
      }
      $content: true;
    }

    // Iterate over $css to wrap provided
    @each $bpt-min, $to-map in $css {
      @each $bpt-max, $bpt-css in $to-map {
        @include elsass-media($bpt-min, $bpt-max) {
          @each $prop, $val in $bpt-css {
            #{$prop}: #{$val};
          }
          @if not $content {
            @content;
          }
        }
      }
    }
  }
}

// 3. Functions
// ============

// 3.1 elsass
// -----------
// Returns a map of needed CSS properties
// and their values from elsass mixin arguments.

@function elsass(
  $media     : null,
  $width     : null,
  $gutter-in : null,
  $gutter-out: null,
  $shift     : null
) {

  // Get provided or default breakpoints.
  $bpt-min: if(nth($media, 1), nth($media, 1), $BPT-MIN);
  $bpt-max: if(type-of($media) == list, nth($media, 2), false);

  // List explicitly and implicitly breakpoints set.
  $bpts-set: _elsass-bpts-set($bpt-min, $bpt-max);

  $out: null; // To store CSS properties and values per breakpoint.

  // Get and store each breakpoint related CSS.
  @each $bpt in $bpts-set {
    $i: index($bpts-set, $bpt);
    $bpt-next: null;

    @if $i == length($bpts-set) {
      $bpt-next: if($bpt-max, nth($BPTS, index($BPTS, $bpt) + 1), false);
    } @else {
      $bpt-next: nth($bpts-set, $i + 1);
    }

    $bpt-css: (); // To store the current breakpoint CSS.

    // Get $width related CSS.
    @if $width {
      $silent: _elsass-gutter-silent($gutter-out);
      $gaps: false;

      @if $gutter-out {
        $gaps: _elsass-gutter-map(if($silent, $silent, $gutter-out));
      }

      @each $val in $width {
        $prop: if(index($width, $val) == 1, width, max-width);
        $gap-width: if($gaps, map-get($gaps, 'right') map-get($gaps, 'left'), false);
        $val: if($prop == max-width and $val == true, $bpt, $val);
        $val: elsass-width($val, ($bpt: $gap-width));
        $bpt-css: map-merge($bpt-css, (#{$prop}: $val));
      }
    }

    // Get $gutter-in and/or $gutter-out related CSS.
    @each $prop, $gutter in (padding: $gutter-in, margin: $gutter-out) {

      @if $gutter {
        $alt: null;
        $alt-next: null;

        @if $prop == margin {
          $bpt-css: map-merge($bpt-css, (box-sizing: border-box));

          @if $shift {
            $alt: nth($shift, 1);
            $shift-next: if(type-of($shift) == list, nth($shift, 2), false);
          }
        }

        $bpt-gutter: _elsass-gutter-css($bpt, $gutter, $alt, $alt-next);

        @if map-has-key($bpt-gutter, 'shorthand') {
          $shorthand: map-get($bpt-gutter, 'shorthand');
          $bpt-css: map-merge($bpt-css, ($prop: $shorthand));
        } @else {
          @each $side, $val in $bpt-gutter {
            $bpt-css: map-merge($bpt-css, (#{$prop}-#{$side}: $val));
          }
        }
      }
    }

    // Merge breakpoints related CSS by optimizing media-queries.
    $bpt-out: ($bpt: ($bpt-next: $bpt-css));
    $out: if($out, _elsass-merge-bpt($out, $bpt-out), $bpt-out);
  }

  @return $out;
}

// 3.2 _elsass-bpts-set
// --------------------
// Get a list of breakpoints explicitly and implicitly set.
// @param   $from  Smallest breakpoint;
// @param   $to    Biggest Breakpoint;
// @return         Breakpoints list or false;
//
// ┌  _elsass-bpts-set('s', 'l')
// ├  Assuming valid bpts are 's', 'm', 'l' and 'xl';
// └> 's' 'm' 'l'

@function _elsass-bpts-set($from: null, $to: null) {
  // Get the shift of each breakpoint in the $settings map.
  $i-from: if($from, index($BPTS, $from), 1);
  $i-to: if($to, index($BPTS, $to), length($BPTS));

  $out: false;
  // Get a list of explicitly and implicitly breakpoints set.
  @for $i from $i-from through $i-to {
    @if not $to or $i != index($BPTS, $to) {
      $bpt: nth($BPTS, $i);
      $out: if($out, append($out, $bpt), $bpt);
    }
  }

  @return $out;
}

// 3.3 _elsass-gutter-silent
// -------------------------
// Returns a map of needed flex related CSS properties and their values.
// @param   $gutter  CSS flex-wrap value;
// @return           Silent gutter value or false.

@function _elsass-gutter-silent($gutter: null) {
  $out: false;

  @if $gutter == 'silent' {
    $out: map-get($elsass-settings, 'gutter-out');
  } @else if type-of($gutter) == map and map-has-key($gutter, 'silent') {
    $out: map-get($gutter, 'silent');
  }

  @return $out;
}

// 3.4 _elsass-gutter-map
// ----------------------
// Return a map of side values from a single value
// or a list of two or four values — like padding/margin values.
// @param   $gap  Single value or list of two or four values;
// @return        Map of side values or false.
//
// ┌  _elsass-gutter-map(false .5);
// └> (top: false, left: .5, bottom: false, $right: .5)

@function _elsass-gutter-map($gap: null) {
  // Get $gap as a four values list.
  @if type-of($gap) == number {
    $gap: $gap $gap $gap $gap;
  } @else if type-of($gap) == list and length($gap) == 2 {
    $gap: nth($gap, 1) nth($gap, 2) nth($gap, 1) nth($gap, 2);
  } @else if type-of($gap) == map {
    $vals: null;
    @each $side in $SIDES {
      $val: if(map-has-key($gap, $side), map-get($gap, $side), false);
      $vals: if($vals == null, $val, append($new-gap, $val));
    }
    $gap: $vals;
  }

  $out: false;

  @each $side in $SIDES {
    $i: index($SIDES, $side);
    $val: nth($gap, $i);
    $out: if($out, map-merge($out, ($side: $val)), ($side: $val));
  }

  @return $out;
}

// 3.5 _elsass-gutter-css
// ----------------------
// Returns a map of needed flex related CSS properties and their values.
// @param  $bpt         Breapoint;
// @param  $gutter      Breakpoint related gutter ratio(s) or CSS value(s);
// @param  $shift       Ratio;
// @param  $shift-next  CSS flex-wrap value;
// @return              Map of side values or false.

@function _elsass-gutter-css(
  $bpt       : null,
  $gutter    : null,
  $shift     : null,
  $shift-next: null
) {

  $out: ();
  $silent: _elsass-gutter-silent($gutter);
  $shorthand: null;

  @if $gutter or $shift {
    // Get a map of each side $gutter value
    $gaps: false false false false;

    @if $gutter {
      $gaps: _elsass-gutter-map(if($silent, $silent, $gutter));
    }

    // Get a map of each side $shift value.
    $shifts: ();

    @if $shift {
      $shift-next: if(type-of($shift) == list, nth($shift, 2), false);
      $shifts: _elsass-shift-map(nth($shift, 1), $shift-next);
    }

    // Get a map of each margin side value.
    $vals: ();

    @if $silent and $shifts {
      @each $side, $alt in $shifts {
        @if type-of($alt) == number {
          $gap: map-get($gaps, $side);
          $val: elsass-gutter(if($GUTTER, $gap, ($bpt: $gap)), $alt);
        } @else {
          $val: $alt;
        }
        $vals: map-merge($vals, ($side: $val));
      }
    } @else {
      @each $side in $SIDES {
        $val: null;

        @if map-has-key($shifts, $side) {
          $alt: map-get($shifts, $side);
          @if type-of($alt) == number {
            $gap: map-get($gaps, $side);
            $val: elsass-gutter(if($GUTTER, $gap, ($bpt: $gap)), $alt);
          } @else {
            $val: $alt;
          }
        } @else {
          $gap: map-get($gaps, $side);
          $val: elsass-gutter(if($GUTTER, $gap, ($bpt: $gap)));
        }

        $vals: map-merge($vals, ($side: $val));
      }
    }

    // Get a margin shorthand value if possible.
    $shorthand: if($silent, false, _elsass-gutter-short($vals...));

    // Store margin shorthand or side values.
    @if $shorthand {
      $out: map-merge($out, ('shorthand': $shorthand));
    } @else {
      @each $side in $SIDES {
        $val: map-get($vals, $side);
        @if $val != false {
          $out: map-merge($out, (#{$side}: $val));
        }
      }
    }
  }

  @return $out;
}

// 3.6 _elsass-shift-map
// ---------------------
// Returns a map of needed flex related CSS properties and their values.
// @param   $shift       CSS flex-direction value;
// @param   $shift-next  CSS flex-wrap value;
// @return               Map of …
//
// ┌  _elsass-shift-map(-1/4);
// └> (left: -1/4, right: 1/4)

@function _elsass-shift-map($shift: null, $shift-next: null) {

  $out: ();

  @if type-of($shift) == number {
    $shift-left: $shift;
    $out: map-merge($out, ('left': $shift-left));
    @if $shift-next {
      $out: map-merge($out, ('right': -$shift-left));
    }
  } @else {
    @if $shift == 'center' or $shift == 'pull' {
      $out: map-merge($out, ('right': auto));
    }
    @if $shift == 'center' or $shift == 'push' {
      $out: map-merge($out, ('left': auto));
    }
  }

  @return $out;
}

// 3.7 _elsass-gutter-short
// ------------------------
// Returns a padding/margin shorthand value from four side values if possible.
// @param   $top     Top CSS value;
// @param   $right   Right CSS value;
// @param   $bottom  Bottom CSS value;
// @param   $left    Left CSS value;
// @return           Shorthand value or false.
//
// ┌  _elsass-gutter-short(10px, auto, 10px, auto);
// └> 10px auto

@function _elsass-gutter-short(
  $top   : null,
  $right : null,
  $bottom: null,
  $left  : null
) {

  $out: false;

  @if $top and $top == $bottom and $right and $right == $left {
    $out: if($top == $right, $top, $top $right);
  }

  @return $out;
}

// 3.8 _elsass-merge-bpt
// ---------------------
// Merge map of CSS stored per media-queries related breakpoints
// in a way to optimize the outpout.
// @param   $out  Map of CSS stored per media-queries relative breakpoints;
// @param   $map  Map of the following breapoint CSS;
// @return        Map of CSS per media-queries.
//
// ┌  $out: (s: (m: (width: 25%, margin: 10px)));
// ├  $bpt-map: (m: (l: (width: 25%, margin: 15px)));
// ├  elsass-merge($out, $bpt-map);
// └> (s: (m: (margin: 10px), l: (width: 25%)),
//     m: (l: (margin: 15px)));

@function _elsass-merge-bpt($out, $bpt-map) {
  // Breakpoint related variables.
  $bpt: nth(map-keys($bpt-map), 1);
  $submap: map-get($bpt-map, $bpt);
  $bpt-next: nth(map-keys($submap), 1);
  $bpt-css: map-get($submap, $bpt-next);

  $new-css: ();

  @each $bpt-prop, $bpt-val in $bpt-css {
    @each $bpt-from, $map-to in $out {
      @if map-has-key($map-to, $bpt) {
        $to-css: map-get($map-to, $bpt);
        @if map-get($to-css, $bpt-prop) == $bpt-val {
          // Remove duplicated CSS.
          $bpt-css: map-remove($bpt-css, $bpt-prop);
          $to-css: map-remove($to-css, $bpt-prop);
          // Move duplicated CSS in an extended media-query.
          $new-css: map-merge($new-css, ($bpt-prop: $bpt-val));
          $new-map-to: ($bpt: $to-css, $bpt-next: $new-css);
          $map-to: map-merge(map-get($out, $bpt-from), $new-map-to);

          $out: map-merge($out, ($bpt-from: ($map-to)));
        }
        $out: map-merge($out, ($bpt: ($bpt-next: $bpt-css)));
      }
    }
  }

  @return $out;
}
