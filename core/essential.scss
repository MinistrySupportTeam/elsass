// Copyright (c) 2016 Nicolas Morand (https://twitter.com/NicolasGraph)

// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// ------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// 1.   Settings
// 1.1  Variables
// 1.2  Constants
// 2.   Mixin
// 2.1  elsass-media
// 3.   Functions
// 3.1  el_width
// 3.2  el_gutter

// 1. Settings
// ===========

// 1.1 Variables
// -------------

$elsass: (
  'global': (
    'gutter-base': 32px,
  ),
  'responsive': (
    's': (                          // Each key is a custom breakpoint.
      'container-max-width': 480px, // Max-width to optionally apply to containers.
      'gutter-base'        : 24px,
    ),
    'm': (
      'device-min-width'   : 640px, // Media-query min-width; useless for the first bpt.
      'container-max-width': 800px,
      'gutter-base'        : 32px,
    ),
    'l': (
      'device-min-width'   : 1024px,
      'container-max-width': 1000px,
      'gutter-base'        : 40px,
    ),
    'xl': (
      'device-min-width'   : 1440px,
      'container-max-width': 1280px,
      'gutter-base'        : 48px,
    )
  )
) !default;

// 1.2 Layout constants -> Keep this untouched!
// --------------------

$GLOBAL    : if(map-has-key($elsass, 'global'), map-get($elsass, 'global'), null);
$GUTTER    : if($GLOBAL and map-has-key($GLOBAL, 'gutter-base'), map-get($GLOBAL, 'gutter-base'), null);
$RESPONSIVE: map-get($elsass, 'responsive');
$BPTS      : map-keys($RESPONSIVE); // Breakpoints list.
$BPT-MIN   : nth($BPTS, 1); // Smallest breakpoint.
$SIDES     : 'top', 'right', 'bottom', 'left';

// 2. Mixin
// ========

// 2.1 elsass-media
// --------------
// Wrap CSS in a media-query.
// @param   $from  min-width related breakpoint or value;
// @param   $to    max-width related breakpoint or value;
// @return         CSS content wrapped in a media query or content only;
//
// ┌  elsass-media('m', 'l') { width: 25%; }
// ├  Assuming device min-widths for 'm' and 'l' breakpoints are 640px and 1024px…
// └> @media screen and (min-width: 640px) and (max-width: 1023px) {
//      width: 25%;
//    }

@mixin elsass-media($from: null, $to: null) {
  $mq: false; // Media-query

  // Set a media-query min-width if $from is set and is not the first bpt.
  @if $from and $from != $BPT-MIN {
    @if index($BPTS, $from) {
      $from: map-get(map-get($RESPONSIVE, $from), 'device-min-width');
    }
    $mq: '(min-width: #{$from})';
  }

  // Set a media-query max-width if $to is set.
  @if $to {
    @if index($BPTS, $to) {
      $to: map-get(map-get($RESPONSIVE, $to), 'device-min-width') - 1;
    }
    $mq: if($mq, $mq ' and ', '') '(max-width: #{$to})';
  }

  // Wrap @content in a media query if set.
  @if $mq {
    @media screen and #{$mq} {
      @content;
    }
  } @else {
    @content;
  }
}

// 3. Functions
// ============

// 3.1 elsass-width
// ----------------
// Returns a map of needed width related CSS properties and their values.
// @param   $width         CSS length, ratio of the container width or
//                         breakpoint name to use the related container max-width;
// @param   $gutter-width  Sum of left and right gutter values/ratios to subtract
//                         from the width; a list of two values can be used
//                         for not comparable values;
//                         For responsive gutters, enter a breakpoint name
//                         to use the breakpoint related gutter base
//                         or use the above value(s) as a map value
//                         where the key is the breakpoint name;
// @return                 CSS length.
//
// ┌  width: elsass-width(1/4, 'm');
// ├  Assuming the gutter base is 30px for the 'm' breakpoint…
// ├> width: calc(25% - 30px);
// ├  Assuming the gutter base is 5% for the 'm' breakpoint…
// └> width: 20%;

@function elsass-width($width: null, $gutter-width: null) {

  @if type-of($width) == string {
    $width: map-get(map-get($RESPONSIVE, $width), 'container-max-width');
  } @else if unitless($width) {
    $width: percentage($width);
  }

  $calc: null;

  @if $gutter-width {
    $bpt: null;

    @if type-of($gutter-width) == map {
      $bpt: nth(map-keys($gutter-width), 1);
      $gutter-width: map-get($gutter-width, $bpt);
    }

    // Get a margin value to subtract.
    @each $gutter in $gutter-width {
      $val: if($bpt, elsass-gutter(($bpt: $gutter)), elsass-gutter($gutter));
      @if $calc and comparable($calc, $val) {
        $calc: $calc + $val;
      } @else {
        $calc: if($calc, append($calc, $val), $val);
      }
    }
    $gutter-width: $calc;

    $calc: null;
    // Calculate width according to margins.
    @each $val in $gutter-width {
      $abs: abs($val);
      @if comparable($width, $val) {
        $width: if($val == $abs, $width - $abs, $width + $abs);
      } @else {
        $operator: if($val == $abs, '-', '+');
        @if $calc {
          $calc: append($calc, #{$operator} #{$abs});
        } @else {
          $calc: #{$operator} #{$abs};
        }
      }
    }
  }

  @return if($calc, calc(#{$width} #{$calc}), $width);
}

// 3.2 elsass-gutter
// -----------------
// Return a map of side values from a single value or a list of two or four values.
// @param   $gutter  CSS length or ratio of the gutter base;
//                   For responsive gutters, enter a breakpoint name
//                   to use the breakpoint related gutter base
//                   or use a above value(s) as a map value
//                         where the key is the breakpoint name
// @param   $shift   CSS length or ratio of the container width (can be negative);
// @return           CSS length.
//
// ┌  margin-left: elsass-gutter(('m': 0.5), 1/4);
// ├  Assuming the gutter base is 30px for the 'm' breakpoint…
// ├> margin-left: calc(15px + 25%);
// ├  Assuming the gutter base is 5% for the 'm' breakpoint…
// └> margin-left: 27.5%;

@function elsass-gutter($gutter: null, $shift: null) {

  @if $gutter {
    @if type-of($gutter) == map {
      $bpt: nth(map-keys($gutter), 1);
      $gutter-base: map-get(map-get($RESPONSIVE, $bpt), 'gutter-base');
      $gutter: map-get($gutter, $bpt) * $gutter-base;
    } @else if map-has-key($RESPONSIVE, $gutter) {
      $gutter: map-get(map-get($RESPONSIVE, $gutter), 'gutter-base');
    } @else if unitless($gutter) {
      $gutter: $gutter * $GUTTER;
    }
  }

  @if $shift {

    @if unitless($shift) {
      $shift: percentage($shift);
    }

    @if $gutter {
      $abs: abs($shift);
      @if comparable($gutter, $abs) {
        $gutter: if($shift == $abs, $gutter + $abs, $gutter - $abs);
      } @else {
        @if $shift == $abs {
          $gutter: calc(#{$gutter} + #{$abs});
        } @else {
          $gutter: calc(#{$gutter} - #{$abs});
        }
      }
    }
  }

  @return if($gutter, $gutter, $shift);
}
