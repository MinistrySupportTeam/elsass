// Copyright (c) 2016 Nicolas Morand (https://twitter.com/NicolasGraph)

// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// ------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// 1. Settings
// ===========
// 1.1 Layout variables
// 1.2 Layout constants
// 1.3 Default mixin argument values

// 2. CSS base
// ===========

// 3. Mixins (underscore for nested mixin)
// =========
// 3.1 _el-bpt
// 3.2 el-sass

// 4. Functions (underscore for nested functions)
// ============
// 4.1 el-sass
// 4.2 el-flex
// 4.3 el-width-val
// 4.4 el-padding
// 4.5 el-margin
// 4.6 _el-shift
// 4.7 el-gutter-val
// 4.8 _el-gutter-shorthand
// 4.9 _el-bpts-set
// 4.10 _el-check

// 1. Settings
// ===========

// 1.1 Layout variables
// --------------------
$settings: (
  's': (                          // Each key is a custom breakpoint.
    'container-max-width': 480px, // Max-width to optionally apply to containers.
    'gutter-base'        : 24px,
  ),
  'm': (
    'device-min-width'   : 640px, // Media-query min-width (useless for the first breakpoint).
    'container-max-width': 800px,
    'gutter-base'        : 32px,
  ),
  'l': (
    'device-min-width'   : 1024px,
    'container-max-width': 1000px,
    'gutter-base'        : 40px,
  ),
  'xl': (
    'device-min-width'   : 1440px,
    'container-max-width': 1280px,
    'gutter-base'        : 48px,
  )
) !default;

// 1.2 Layout constants -> Keep this untouched!
// --------------------
$BPTS: map-keys($settings); // Breakpoints list.
$BPT-MIN: nth($BPTS, 1); // Smallest breakpoint.
$SIDES: 'top', 'right', 'bottom', 'left';

// 1.3 Default mixin argument values
// ---------------------------------
$el-sass-settings: (
  'media'     : $BPT-MIN,
  'flow'      : row wrap,
  'width'     : 1 true,
  'gutter-in' : 0.5,
  'gutter-out': 0.5,
  'shift'     : null,
) !default;

// 2. CSS base
// ===========

html { box-sizing: border-box; }

*,
*:before,
*:after { box-sizing: inherit; }

// 3. Mixins
// =========

// 3.1 _el-bpt
// -----------
// Generate a media-query.
// @param   $from  breakpoint or min-width value;
// @param   $to    breakpoint or max-width value.
// @return  content wrapped in a media query or false.
// @see     3.2 elsass
//
// _el-bpt('s' 'l') { width: 100%; }
// @media screen and (min-width: 480px) and (max-width: 959px) { width: 100%; }

@mixin _el-bpt($from: null, $to: null) {

  $mq: false; // Media-query

  // Set a media-query min-width if $from is set
  // and not the first breakpoint.
  @if $from and $from != $BPT-MIN {
    @if index($BPTS, $from) {
      $from-settings: map-get($settings, $from);
      $from: map-get($from-settings, 'device-min-width');
    }
    $mq: '(min-width: #{$from})';
  }

  // Set a media-query max-width if needed.
  @if $to {
    @if index($BPTS, $to) {
      $to-settings: map-get($settings, $to);
      $to: map-get($to-settings, 'device-min-width') - 1;
    }
    $mq: if($mq, $mq ' and ', '') '(max-width: #{$to})';
  }

  // Wrap @content in a media query if set.
  @if $mq {
    @media screen and #{$mq} {
      @content;
    }
  } @else {
    @content;
  }
}

// 3.2 el-sass
// -----------
// Generate whatever responsive element you need.
// @param  $media       Breakpoint(s);
// @param  $flow        flex-direction flex-wrap;
// @param  $width       width (ratio) max-width (true / CSS value);
// @param  $gutter-in   Padding value(s) or ratio(s) of the breakpoint gaps;
// @param  $gutter-out  Margin value(s) or ratio(s) of the breakpoint gaps;
// @param  $shift       'pull', 'push', 'center' or ratio of the container width
//                      optionally followed by true to pull or push next items.
@mixin el-sass(
  $media     : null,
  $flow      : null,
  $width     : null,
  $gutter-in : null,
  $gutter-out: null,
  $shift     : null
) {

  // Set arguments to their default values if needed.
  $args: (
    'media'     : $media,
    'flow'      : $flow,
    'width'     : $width,
    'gutter-in' : $gutter-in,
    'gutter-out': $gutter-out,
    'shift'     : $shift,
  );

  $default: null;

  @each $arg, $val in $args {
    @if ($val == true or $val == '…') or ($val == null and $default) {
      $args: map-merge($args, ($arg: map-get($el-sass-settings, $arg)));
      @if not $default and $val == '…' {
        $default: true;
      }
    }
  }

  // Check arguments values.
  $check: _el-check($args...);

  // Get the provided breakpoints.
  $media: map-get($args, 'media');
  $from: if(nth($media, 1), nth($media, 1), $BPT-MIN);
  $to: if(type-of($media) == list, nth($media, 2), false);

  // Wrap each breakpoint related rules in dedicated media-queries.
  @if map-remove($args, 'media') != () {
    $css: el-sass($args...);
    @each $bpt-min, $to-map in $css {
      @each $bpt-max, $bpt-css in $to-map {
        @include _el-bpt($bpt-min, $bpt-max) {
          @each $prop, $val in $bpt-css {
            #{$prop}: #{$val};
          }
          @if $bpt-min == $from and $bpt-max == $to {
            @content;
          }
        }
      }
    }
  }
}

// 4. Functions
// ============

// 4.1 el-sass
// -----------
// Returns a map of needed CSS properties
// and their values from elsass mixin arguments.
//
// @see  3.2 elsass
@function el-sass(
  $media     : null,
  $flow      : null,
  $width     : null,
  $gutter-in : null,
  $gutter-out: null,
  $shift     : null
) {

  // Get breakpoints.
  $bpt-min: if(nth($media, 1), nth($media, 1), $BPT-MIN);
  $bpt-max: if(type-of($media) == list, nth($media, 2), false);

  // List breakpoints explicitly and implicitly set.
  $bpts-set: _el-bpts-set($bpt-min, $bpt-max);

  $out: null; // To store CSS properties and values per breakpoint.

  @each $bpt in $bpts-set {
    $i: index($bpts-set, $bpt);
    $bpt-next: null;

    // Get the next breakpoint.
    @if $i == length($bpts-set) {
      $bpt-next: if($bpt-max, nth($BPTS, index($BPTS, $bpt) + 1), false);
    } @else {
      $bpt-next: nth($bpts-set, $i + 1);
    }

    $bpt-css: (); // To store the current breakpoint CSS.

    @if $flow {
      $dir: if($flow, nth($flow, 1), false);
      $wrap: if(type-of($flow) == list, nth($flow, 2), false);
      $bpt-css: map-merge($bpt-css, el-flex($dir, $wrap));
    }

    @if $width {
      $silent: el_silent($gutter-out);
      $gaps: false false false false;
      @if $gutter-out {
        $gaps: _el-gutter-vals(if($silent, $silent, $gutter-out));
      }
      @each $val in $width {
        $prop: if(index($width, $val) == 1, width, max-width);
        $val: el-width-val($bpt, $val, map-get($gaps, 'right'), map-get($gaps, 'left'));
        $bpt-css: map-merge($bpt-css, (#{$prop}: $val));
      }
    }

    @each $prop, $gutter in (padding: $gutter-in, margin: $gutter-out) {
      @if $gutter {
        $alt: null;
        $alt-next: null;
        @if $prop == margin and $shift {
          $alt: nth($shift, 1);
          $shift-next: if(type-of($shift) == list, nth($shift, 2), false);
        }
        $bpt-gutter: _el-gutter($bpt, $gutter, $alt, $alt-next);
        @if map-has-key($bpt-gutter, 'shorthand') {
          $bpt-css: map-merge($bpt-css, ($prop: map-get($bpt-gutter, 'shorthand')));
        } @else {
          @each $side, $val in $bpt-gutter {
            $bpt-css: map-merge($bpt-css, ($prop-$side: $val));
          }
        }
      }
    }

    // Reduce and store each breakpoint related CSS.
    $bpt-out: ($bpt: ($bpt-next: $bpt-css));
    $out: if($out, _el-merge($out, $bpt-out), $bpt-out);
  }

  @return $out;
}

// 4.1 el-merge
// ------------
// Merge map of CSS stored per media-queries related breakpoints
// in a way to optimize the outpout.
//
// @param   $out  Map of CSS stored per media-queries relative breakpoints;
// @param   $map  Map of the following breapoint CSS
// @return  map of CSS per media-queries.
// @see  3.2 elsass
//
// $out: (s: (m: (width: 100%, margin: 10px)));
// $map: (m: (l: (width: 100%, margin: 15px)));
// el-merge($out, $map)
// => (s: (m: (margin: 10px), l: (width: 100%)),
//     m: (l: (margin: 15px)));
@function _el-merge($out, $map) {
  $bpt: nth(map-keys($map), 1);
  $submap: map-get($map, $bpt);
  $bpt-next: nth(map-keys($submap), 1);
  $bpt-css: map-get($submap, $bpt-next);

  $new-css: ();

  @each $prop, $val in $bpt-css {
    @each $bpt-min, $to-map in $out {
      @if map-has-key($to-map, $bpt) {
        $to-css: map-get($to-map, $bpt);
        @if map-get($to-css, $prop) == $val {
          // Remove duplicated CSS.
          $bpt-css: map-remove($bpt-css, $prop);
          $to-css: map-remove($to-css, $prop);
          // Move duplicated CSS.
          $new-css: map-merge($new-css, ($prop: $val));
          $new-to-map: ($bpt: $to-css, $bpt-next: $new-css);
          $to-map: map-merge(map-get($out, $bpt-min), $new-to-map);

          $out: map-merge($out, ($bpt-min: ($to-map)));
        }
        $out: map-merge($out, ($bpt: ($bpt-next: $bpt-css)));
      }
    }
  }

  @return $out;
}

// 4.2 el-silent
// -------------
// Returns a map of needed flex related CSS properties and their values.
// @param   $gutter  CSS flex-wrap value;
// @return  gutter value or false;
// @see     3.2 elsass.
@function el-silent($gutter: null) {
  $silent: false;

  @if $gutter == 'silent' {
    $silent: map-get($el-sass-settings, 'gutter-out');
  } @else if type-of($gutter) == map and map-has-key($gutter, 'silent') {
    $silent: map-get($gutter, 'silent');
  }

  @return $silent;
}

// 4.2 el-margin
// -------------
// Returns a map of needed flex related CSS properties and their values.
// @param  $bpt         Breapoint;
// @param  $gutter      Breakpoint related gutter ratio(s) or CSS value(s);
// @param  $shift       Ratio ;
// @param  $shift-next  CSS flex-wrap value;
// @see    3.2 elsass
@function _el-gutter($bpt: null, $gutter: null, $shift: null, $shift-next: null) {
  $margin: ();
  $silent: el_silent($gutter);
  $shorthand: null;

  @if $gutter or $shift {
    // Get a map of each side $gutter value
    $gaps: false false false false;

    @if $gutter {
      $gaps: _el-gutter-vals(if($silent, $silent, $gutter));
    }

    // Get a map of each side $shift value.
    $shifts: ();

    @if $shift {
      $shift-next: if(type-of($shift) == list, nth($shift, 2), false);
      $shifts: _el-shift(nth($shift, 1), $shift-next);
    }

    // Get a map of each margin side value.
    $vals: ();

    @if $silent and $shifts {
      @each $side, $alt in $shifts {
        $val: el-gutter-val($bpt, map-get($gaps, $side), $alt);
        $vals: map-merge($vals, ($side: $val));
      }
    } @else {
      @each $side in $SIDES {
        $alt: null;
        @if map-has-key($shifts, $side) {
          $alt: map-get($shifts, $side);
        }
        $val: el-gutter-val($bpt, map-get($gaps, $side), $alt);
        $vals: map-merge($vals, ($side: $val));
      }
    }

    // Get a margin shorthand value if possible.
    $shorthand: if($silent, false, _el-gutter-shorthand($vals...));

    // Store margin shorthand or side values.
    @if $shorthand {
      $margin: map-merge($margin, ('shorthand': $shorthand));
    } @else {
      @each $side in $SIDES {
        $val: map-get($vals, $side);
        @if $val != false {
          $margin: map-merge($margin, (#{$side}: $val));
        }
      }
    }
  }

  @return $margin;
}

// 4.2 el-shift
// -----------
// Returns a map of needed flex related CSS properties and their values.
// @param  $shift       CSS flex-direction value;
// @param  $shift-next  CSS flex-wrap value;
// @see    3.2 elsass
@function _el-shift($shift: null, $shift-next: true) {
  $shifts: ();

  @if type-of($shift) == number {
    $shift-left: $shift;
    $shifts: map-merge($shifts, ('left': $shift-left));
    @if not $shift-next {
      $shifts: map-merge($shifts, ('right': -$shift-left));
    }
  } @else if $shift == 'center' or $shift == 'pull' or $shift == 'push' {
    @if $shift == 'center' or $shift == 'pull' {
      $shifts: map-merge($shifts, ('right': auto));
    }
    @if $shift == 'center' or $shift == 'push' {
      $shifts: map-merge($shifts, ('left': auto));
    }
  }

  @return $shifts;
}

// 4.2 el-flex
// -----------
// Returns a map of needed flex related CSS properties and their values.
// @param   $dir   CSS flex-direction value;
// @param   $wrap  CSS flex-wrap value;
// @return  a map of flex related properties and their values;
// @see     3.2 elsass.
@function el-flex($dir: null, $wrap: null) {
  $out: (display: flex);

  @if ($dir and $dir != row) and ($wrap and $wrap != nowrap) {
    $out: map-merge($out, (flex-flow: $dir $wrap));
  } @else if $dir and $dir != row {
    $out: map-merge($out, (flex-direction: $dir));
  } @else if $wrap and $wrap != nowrap {
    $out: map-merge($out, (flex-wrap: $wrap));
  }

  @return $out;
}

// 4.3 el-width-val
// ----------------
// Returns a map of needed width related CSS properties and their values.
// @param   $bpt    Breakpoint as a $settings key;
// @param   $width  Width value or ratio of the container width;
// @param   $right  Margin value(s) or ratio(s) of the breakpoint gaps;
// @param   $left   Margin value(s) or ratio(s) of the breakpoint gaps;
// @return  3.2 elsass.
// @see     3.2 elsass.
//
// el-width-val('s', 1/2, 0.5, 0.5) returns: calc(50% - 24px)
// @see    3.2 elsass.
@function el-width-val($bpt: null, $width: null, $right: null, $left: null) {
  $width-out: null;
  $abs-out: null;
  // Get a margin value to subtract.
  $gutters: ('left': $left, 'right': $right);

  @each $side, $gutter in $gutters {
    @if $gutter {
      $gutters: map-merge($gutters, ($side: el-gutter-val($bpt, $gutter)));
    }
  }

  $left: map-get($gutters, 'left');
  $right: map-get($gutters, 'right');

  $width-out: null;

  @if $left and $left != 0 and $right and $right != 0 {
    $width-out: $right + $left;
  } @else if $left and $left != 0 {
    $width-out: $left;
  } @else if $right and $right != 0 {
    $width-out: $right;
  }

  @if type-of($width) == number and unitless($width) {
    $width: percentage($width);
  } @else if $width == true {
    $width: map-get(map-get($settings, $bpt), 'container-max-width');
  }

  $out: ();
  // Calculate width and max-width values according to margins.

  @if $width-out {
    $abs-out: abs($width-out);
    $calc: null;
    @if comparable($width, $width-out) {
      $calc: if($width-out == $abs-out, $width - $abs-out, $width + $abs-out);
    } @else {
      $operator: if($width-out == $abs-out, '-', '+');
      $calc: calc(#{$width} #{$operator} #{$abs-out});
    }
    $out: $calc;
  } @else {
    $out: $width;
  }

  @return $out;
}

// 4.7 el-gutter-val
// -----------
// Return a map of side values from a single value or a list of two or four values.
// @param   $bpt     Single value or list of two or four values;
// @param   $gutter  Single value or list of two or four values;
// @param   $shift   Single value or list of two or four values;
// @return  CSS value.
// @see     4.4 el-padding, 4.5 el-margin.
//
// _el-gutter-val('s', 0.5, 1/2) => calc(24px + 50%);
@function el-gutter-val($bpt: null, $gutter: null, $shift: null) {

  @if $gutter and unitless($gutter) {
    $gutter: $gutter * map-get(map-get($settings, $bpt), 'gutter-base');
  }

  @if $shift {
    @if type-of($shift) == number {
      @if unitless($shift) {
        $shift: percentage($shift);
      }
    } @else {
      $shift: auto;
    }
    @if $gutter and type-of($shift) == number {
      $abs: abs($shift);
      $operator: if($shift == $abs, '+', '-');
      $gutter: el-calc($gutter, $abs, $operator);
    } @else {
      $gutter: $shift;
    }
  }

  @return $gutter;
}

// 4.7 el-calc
// -----------
// Return a map of side values from a single value or a list of two or four values.
// @param   $gap  Single value or list of two or four values;
// @return  result as value or calc().
// @see     4.4 el-padding, 4.5 el-margin.
//
// _el-calc(5px, 5px, '+') returns
@function el-calc($gap: null, $shift: null, $operator: null) {
  $calc: null;

  @if type-of($shift) == number {
    // Calculate the new left margin value directly or via calc().
    @if comparable($gap, $shift) {
      $calc: $gap #{$operator} $shift;
    } @else {
      $calc: calc(#{$gap} #{$operator} #{$shift});
    }
  }

  @return $calc;
}

// 4.7 el-gutter-vals
// ------------------
// Return a map of side values from a single value
// or a list of two or four values — like padding/margin values.
// @param  $gap  Single value or list of two or four values;
// @return map of side values or false.
// @see    4.4 el-padding, 4.5 el-margin.
//
// _el-gutter-vals(false .5) returns: (top: false, left: .5, bottom: false, $right: .5);
@function _el-gutter-vals($gap: null) {

  // Get $gap as a four values list.
  @if type-of($gap) == number {
    $gap: $gap $gap $gap $gap;
  } @else if type-of($gap) == list and length($gap) == 2 {
    $gap: nth($gap, 1) nth($gap, 2) nth($gap, 1) nth($gap, 2);
  } @else if type-of($gap) == map {
    @each $side in $SIDES {
      $val: if(map-has-key($gap, $side), map-get($gap, $side), false);
      $gap: if($gaps == null, $val, append($new-gap, $val));
    }
  }

  $gaps: false;

  @each $side in $SIDES {
    $i: index($SIDES, $side);
    $gaps: if($gaps, map-merge($gaps, ($side: nth($gap, $i))), ($side: nth($gap, $i)));
  }

  @return $gaps;
}

// 4.8 _el-gutter-shorthand
// ---------------------
// Returns a padding/margin shorthand value from four side values if possible.
// @param   $top     Top CSS value;
// @param   $right   Right CSS value;
// @param   $bottom  Bottom CSS value;
// @param   $left    Left CSS value;
// @return  shorthand value or false.
// @see     4.7 el-gutter-val
//
// _el-gutter-shorthand(10px, auto, 10px, auto) => 10px auto;
@function _el-gutter-shorthand($top: null, $right: null, $bottom: null, $left: null) {
  $shorthand: false;

  @if $top and $top == $bottom and $right and $right == $left {
    $shorthand: if($top == $right, $top, $top $right);
  }

  @return $shorthand;
}

// 4.9 _el-bpts-set
// ----------------
// Get a list of breakpoints explicitly and implicitly set.
// @param   $from  Smallest breakpoint;
// @param   $to    Biggest Breakpoint;
// @return  Breakpoints list or false;
// @see     3.2 elsass.
//
// Assuming valid bpts are 's', 'm', 'l' and 'xl';
// _el-bpts-set('s', 'l') => 's' 'm' 'l';
@function _el-bpts-set($from: null, $to: null) {
  // Get the shift of each breakpoint in the $settings map.
  $i-from: if($from, index($BPTS, $from), 1);
  $i-to: if($to, index($BPTS, $to), length($BPTS));

  $out: false;
  // Get a list of explicitly and implicitly breakpoints set.
  @for $i from $i-from through $i-to {
    @if not $to or $i != index($BPTS, $to) {
      $bpt: nth($BPTS, $i);
      $out: if($out, append($out, $bpt), $bpt);
    }
  }

  @return $out;
}

// 4.10 _el-check
// --------------
// Return an error message if an argument value is not valid.
// @see  3.2 el-sass
@function _el-check(
  $media     : null,
  $flow      : null,
  $width     : null,
  $gutter-in : null,
  $gutter-out: null,
  $shift     : null
) {

  @if $media {
    $min: nth($media, 1);
    $i-min: if($min, index($BPTS, $min), 1);
    $max: if(type-of($media) == list, nth($media, 2), false);
    $i-max: if($max, index($BPTS, $max), 1);
    @if (type-of($media) == list and length($media) > 2) or
        ($min and not $i-min and type-of($min) != number) or
        ($max and $i-max <= $i-min and type-of($max) != number) {
      @error '#{&}: "#{$media}" is not a valid value for $media.';
    }
  }

  @if $width {
    $width: nth($width, 1);
    $max-width: if(type-of($width) == list, nth($width, 2), false);
    @if (type-of($media) == list and length($media) > 2) or
        ($width and $width != 'max' and type-of($width) != number) or
        ($max-width and $max-width != true and type-of($width) != number) {
      @error '#{&}: "#{$width}" is not a valid value for $width.';
    }
  }

  @if $flow {
    $dir: nth($flow, 1);
    $wrap: if(type-of($flow) == list, nth($flow, 2), false);
    @if (type-of($flow) == list and length($flow) > 2) or
        ($dir and $dir != column and $dir != row and $dir != row-reverse) or
        ($wrap and $wrap != nowrap and $wrap != wrap and $wrap != wrap-reverse) {
      @error '#{&}: "#{$flow}" is not a valid value for $flow.';
    }
  }

  $gutters: (
    'gutter-in' : $gutter-in,
    'gutter-out': $gutter-out,
  );

  @each $gutter, $vals in $gutters {
    $vals-type: type-of($vals);
    @if $vals {
      @if $vals-type == map {
        @each $side, $val in $vals {
          @if (not index($SIDES, $side)) or ($val and type-of($val) != number) {
            @error '#{&}: "#{$vals}" is not a valid value for $#{$gutter}.';
          }
        }
      } @else if $vals-type == list {
        @if length($vals) != 2 and length($vals) != 4 {
          @error '#{&}: "#{$vals}" is not a valid value for $#{$gutter}.';
        } @else {
          @each $val in $vals {
            @if $val and type-of($val) != number {
              @error '#{&}: "#{$vals}" is not a valid value for $#{$gutter}.';
            }
          }
        }
      } @else if $vals-type != number and ($gutter == 'gutter-out' and $vals != 'silent') {
        @error '#{&}: "#{$vals}" is not a valid value for $#{$gutter}.';
      }
    }
  }

  @if $shift {
    $to: nth($shift, 1);
    $next: if(type-of($shift) == list, nth($shift, 2), false);
    @if (type-of($shift) == list and length($shift) > 2) or
        ($to != 'push' and $to != 'center' and ($next and type-of($to) != number)) or
        $next and $next != true {
      @error '#{&}: "#{$shift}" is not a valid value for $shift.';
    }
  }

  @return true;
}
