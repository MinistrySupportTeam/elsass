// -----------------------------------------------------------------------------
// Copyright (c) 2016 Nicolas Morand (https://twitter.com/NicolasGraph)
// -----------------------------------------------------------------------------

// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// -----------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// Table of contents
// -----------------------------------------------------------------------------
// 1. Settings     Where you can easily customize things!
// 2. CSS base     Don't you already set that?
// 3. Mixins
// 3.1 bpt         Mainly used by other mixins.
// 3.1 this        Generic resposive mixin.
// 3.2 children    Apply "this" mixin to defined children elements.
// 4. Functions    Exclusively used by mixins.
// 4.1 this
// 4.2 spacing
// 4.3 spacing-val
// 4.4 position
// 4.5 bpts

// -----------------------------------------------------------------------------
// 1. Settings
// -----------------------------------------------------------------------------

$settings: (
    "s": (                           // Each $settings key is used as a custom breakpoint.
        "content-max-width" : 480px, // Max-width to optionally apply to containers.
        "vertical-spacing"  : 24px,  // Top and bottom gutters.
        "horizontal-spacing": 16px    // Right and left gutters.
    ),
    "m": (
        "device-min-width"  : 640px, // Media-query min-width (useless for the first breakpoint).
        "content-max-width" : 800px,
        "vertical-spacing"  : 32px,
        "horizontal-spacing": 24px
    ),
    "l": (
        "device-min-width"  : 1024px,
        "content-max-width" : 1000px,
        "vertical-spacing"  : 48px,
        "horizontal-spacing": 32px
    ),
    "xl": (
        "device-min-width"  : 1440px,
        "content-max-width" : 1280px,
        "vertical-spacing"  : 54px,
        "horizontal-spacing": 48px
    )
);

// -----------------------------------------------------------------------------
// 2. CSS base
// -----------------------------------------------------------------------------

html { box-sizing: border-box; }

html * { box-sizing: inherit; }

// -----------------------------------------------------------------------------
// 3. Mixins
// -----------------------------------------------------------------------------

// 3.1 bpt
// -----------------------------------------------------------------------------
// Generate a media-query.
// @param    $from    min-width as a custom breakpoint or CSS value;
// @param    $to      max-width as a custom breakpoint or CSS value.
// @see      3.1 this
// -----------------------------------------------------------------------------
@mixin bpt($from: null, $to: null) {
    $mq: null;

    @if $from and $from != nth(map-keys($settings), 1) {
        @if map-has-key($settings, $from) {
            // $from is a custom breakpoint; get the related value if it exists.
            $from-settings: map-get($settings, $from);
            $from: map-get($from-settings, "device-min-width");
        }
        // Set the media-query min-width.
        $mq: "(min-width: #{$from})";
    }

    @if $to {
        // If $to is a $settings key; get the related value.
        @if map-has-key($settings, $to) {
            $to-settings: map-get($settings, $to);
            $to: map-get($to-settings, "device-min-width") - 1;
        }
        // Add or set the media-query max-width.
        @if $from and $from != nth(map-keys($settings), 1) {
            $mq: $mq " and (max-width: #{$to})";
        } @else {
            $mq: "(max-width: #{$to})";
        }
    }

    // Generate the CSS media-query if it exists.
    @if $mq {
        @media screen and #{$mq} {
            @content;
        }
    } @else {
        @content;
    }
}

// 3.2 this
// -----------------------------------------------------------------------------
// Generate a responsive flex row/grid or item.
// @param    $media       Custom Breakpoint(s) used as media-query values;
// @param    $flow        "flex-row", "flex-grid" or false;
// @param    $width       Fraction/factor of the container width,
//                        "max-width" can also be used to generate a width of 100%
//                        followed by the responsive max-width provided in $settings.
// @param    $gutter      Up to four values (see doc.);
// @param    $position    "pull", "push", "center" or fraction/factor
//                        of the container width;
// @param    $padding     Up to four values (see doc.);
// -----------------------------------------------------------------------------
@mixin this($media: null, $flow: null, $width: null, $gutter: null, $position: null, $padding: null) {

    // List breakpoints explicitly or implicitly set.
    $min-bpt: if(nth($media, 1), nth($media, 1), false);
    $max-bpt: if(type-of($media) == list, nth($media, 2), false);
    $bpts: bpts($min-bpt, $max-bpt);

    // Store each breakpoint CSS properties and values.
    $css: ();
    @each $bpt in $bpts {
        // Get each breakpoint CSS properties and values.
        $bpt-css: this($bpt, $flow, $width, $gutter, $position, $padding);
        // Remove useless repeated values through media-queries.
        @each $bpt-prop, $bpt-val in $bpt-css {
            @each $stored-bpt, $stored-css in $css {
                @if map-has-key($stored-css, $bpt-prop) {
                    @if map-get($stored-css, $bpt-prop) == $bpt-val {
                        $bpt-css: map-remove($bpt-css, $bpt-prop);
                    } @else {
                        $bpt-css: map-merge($bpt-css, ($bpt-prop: $bpt-val));
                    }
                }
            }
        }
        $css: map-merge($css, ($bpt: $bpt-css));
    }

    // Generate CSS.
    @each $stored-bpt, $stored-css in $css {
        @if $stored-bpt == nth($bpts, 1) {
            $to-bpt: nth($bpts, length($bpts));
            @include bpt($stored-bpt, if($max-bpt, $to-bpt, false)) {
                @each $prop, $val in map-get($css, $stored-bpt) {
                    #{$prop}: $val;
                }
                @content;
            }
            $css: if($max-bpt, map-remove($css, $to-bpt), $css);
        } @else {
            @include bpt($stored-bpt) {
                @each $prop, $val in map-get($css, $stored-bpt) {
                    #{$prop}: $val;
                }
            }
        }
    }
}

// -----------------------------------------------------------------------------
// 4. Functions
// -----------------------------------------------------------------------------

// 4.1 this
// -----------------------------------------------------------------------------
// Return CSS properties and values for "this" mixin.
// @see    3.1 this
// -----------------------------------------------------------------------------
@function this($media: null, $flow: null, $width: null, $gutter: null, $position: null, $padding: null) {

    // Set a map to store the generated css properties and their values.
    $css : ();

    // Get the media-query related values.
    $min-settings: null;
    $min-width: null;
    $max-width: null;

    @if $media {
        @if nth($media, 1) {
            $min-settings: map-get($settings, nth($media, 1));
        } @else {
            $min-settings: map-get($settings, "s");
        }
    } @else {
        $min-settings: map-get($settings, "s");
    }

    // Set the flex properties from $flow.
    @if $flow {
        $css: map-merge($css, (display: flex));
        $direction: nth($flow, 1);
        $wrap: null;
        @if type-of($flow) == list and nth($flow, 2) != nowrap {
            $wrap: nth($flow, 2);
        }
        @if $direction and $direction != row {
            @if $wrap {
                $css: map-merge($css, (flex-flow: #{$direction $wrap}));
            } @else {
                $css: map-merge($css, (flex-direction: #{$direction}));
            }
        } @else {
            $css: map-merge($css, (flex-wrap: #{$wrap}));
        }
    }

    // Get margin and padding values.
    $css-margins: null;
    $css-positions: null;
    $silent-gutter: null;

    @if $gutter or $position or $padding {
        $spacing: map-get($min-settings, "vertical-spacing") map-get($min-settings, "horizontal-spacing");

        // Set the margins properties from $gutter and $position.
        @if $gutter or $position {
            // Get a map of CSS margins.
            @if type-of($gutter) == map {
                @if not $position {
                    $silent-gutter: true;
                }
                $gutter: map-get($gutter, "silent");
            }
            $css-margins: spacing($spacing, $gutter);
            $css-positions: if($silent-gutter, (), $css-margins);
            @if $position {
                // Alterate margins width $position.
                $css-positions: position($css-positions, $position);
            }
            // Get the margin shorthand or each side value.
            @if map-has-key($css-positions, "global") {
                $css: map-merge($css, (margin: map-get($css-positions, "global")));
            } @else {
                @each $side, $val in $css-positions {
                    $css: map-merge($css, (margin-#{$side}: $val));
                }
            }
        }

        // Set the paddings properties from $padding.
        @if $padding {
            // Get a map of CSS paddings.
            $css-paddings: spacing($spacing, $padding);
            // Get the padding shorthand or each side value.
            @if map-has-key($css-paddings, "global") {
                $css: map-merge($css, (padding: map-get($css-paddings, "global")));
            } @else {
                @each $side, $val in $css-paddings {
                    $css: map-merge($css, (padding-#{$side}: $val));
                }
            }
        }
    }

    // Set the width and max-width properties from $width and $gutter.
    @if $width {
        // Get the margin value to soustract from the width (right and left).
        $gutter-factor: null;
        @if $gutter {
            $right: map-get($css-margins, "right");
            @if $right and $right != 0 {
                $gutter-factor: $right;
            }
            $left: map-get($css-margins, "left");
            @if $left and $left != 0 {
                @if $gutter-factor {
                    $gutter-factor: $gutter-factor + $left;
                } @else {
                    $gutter-factor: $left;
                }
            }
        }

        // Set the width and max-width values.
        $css-width: null;
        $css-max-width: null;
        @if type-of($width) == string {
            $css-width: 100%;
            $css-max-width: map-get($min-settings, "content-max-width");
        } @else {
            $css-width: $width * 100%;
        }

        // Soustract gutters from CSS width and max-width if needed.
        @if $gutter-factor {
            $css-width: calc(#{$css-width} - #{$gutter-factor});
            @if $css-max-width {
                $css-max-width: calc(#{$css-max-width} - #{$gutter-factor});
            }
        }

        $css: map-merge($css, (width: $css-width, max-width: $css-max-width));
    }

    @return $css;
}

// 4.2 spacing
// -----------------------------------------------------------------------------
// Return a map of spacing values from $spacing.
// @param     $base        Default values for vertical and horizontal spacings;
// @param     $spacing     $gutter or $padding mixin argument (see Mixins);
// @return    $spacings    Map of spacing values par side (+"global" as shorthand).
// @see       @mixin this
// -----------------------------------------------------------------------------
@function spacing($base: null, $spacing: null) {

    // Make $spacing a four items list.
    @if type-of($spacing) == list and length($spacing) == 2 {
        $spacing: nth($spacing, 1) nth($spacing, 2) nth($spacing, 1) nth($spacing, 2);
    } @else if type-of($spacing) != list {
        $spacing: $spacing $spacing $spacing $spacing;
    }

    // Set each side margin.
    $sides: "top", "right", "bottom", "left";
    $spacings: ();

    @for $i from 1 through length($spacing) {
        $val: nth($spacing, $i);
        @if $val != false {
            // Get the CSS value.
            $base-i: if($i == 1 or $i == 3, nth($base, 1), nth($base, 2));
            $spacing-val: spacing-val($base-i, $val);
            // Build the map.
            $spacings: map-merge($spacings, (#{nth($sides, $i)}: $spacing-val));
        }
    }

    // Set a margin shorthand if possible.
    $top: map-get($spacings, "top");
    $right: map-get($spacings, "right");
    $bottom: map-get($spacings, "bottom");
    $left: map-get($spacings, "left");

    @if $top and $top == $bottom and $right and $right == $left {
        @if $top == $right {
            $spacings: map-merge($spacings, ("global": $top));
        } @else {
            $spacings: map-merge($spacings, ("global": $top $right));
        }
    }

    @return $spacings;
}

// 4.3 spacing-val
// -----------------------------------------------------------------------------
// Return a css value.
// @param     $base       A CSS value used as a calculation base;
// @param     $val        A $spacing value;
// @return    $spacing    A CSS margin/padding value.
// @see       4.2 spacing
// -----------------------------------------------------------------------------
@function spacing-val($base: null, $val: null) {
    $spacing: null;

    @if $val == true {
        $spacing: $base / 2; // Use the $base val.
    } @else if $val == "nested" {
        $spacing: (-($base / 2)); // Use $base as a negative val.
    } @else if type-of($val) == number and unitless($val) {
        $spacing: if($val == 0, $val, $val * ($base / 2)); // Multiply the $base val.
    } @else {
        $spacing: $val; // Use a custom spacing value.
    }

    @return $spacing;
}

// 4.4 position
// -----------------------------------------------------------------------------
// Atlterate margins depending of the $position value.
// @param     $spacings    Map returned by spacing(),
// @param     $position    Mixin argument
// @return    $spacings    Alterated map
// @see       4.2 spacing + 4.1 this
// -----------------------------------------------------------------------------
@function position($margins, $position) {
    $side: null;
    $val: null;

    @if $position == "center" {
        $margins: map-merge($margins, ("right": auto, "left": auto));
        // Add a margin shorthand if top and bottom values are equal.
        $margin-top: map-get($margins, "top");
        @if $margin-top and $margin-top == map-get($margins, "bottom") {
            $global: if($margin-top == "auto", auto, $margin-top auto);
            $new-margins: ("global": $global);
            $margins: map-merge($margins, $new-margins);
        }
    } @else {
        // Margin shorthand won't be useful anymore.
        @if map-has-key($margins, "global") {
            $margins: map-remove($margins, "global");
        }
        @if $position == "pull" {
            $margins: map-merge($margins, ("right": auto));
        } @else if $position == "push" {
            $margins: map-merge($margins, ("left": auto));
        } @else if type-of($position) == number {
            // Prepare $position to be added, or soustracted if negative.
            $operator: if($position == abs($position), "+", "-");
            $position: percentage(abs($position));
            // Set the margin-left value.
            $gutter: map-get($margins, "left");
            @if $gutter and $gutter != 0 {
                $val: calc(#{$gutter} #{$operator} #{$position});
            } @else {
                $val: #{$operator}$position;
            }
            $margins: map-merge($margins, ("left": #{$val}));
        }
    }

    @return $margins;
}

// 4.5 bpts
// -----------------------------------------------------------------------------
// Get a list of breakpoints explicitly or implicitly set in the this mixin.
// @param     $from        Custom breakpoint used as the min-width;
// @param     $to          Custom breakpoint used as the max-width;
// @return    $bpts-set    A list of breakpoints as $settings map keys.
// @see       3.1 this
// -----------------------------------------------------------------------------
@function bpts($from: null, $to: null) {
    $bpts: map-keys($settings);
    $from: if($from, index($bpts, $from), 1);
    $to: if($to, index($bpts, $to), length($bpts));

    $bpts-set: null;

    @for $i from $from through $to {
        $bpt: nth($bpts, $i);
        $bpts-set: if($bpts-set, append($bpts-set, $bpt), $bpt);
    }

    @return $bpts-set;
}
