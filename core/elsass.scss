// -----------------------------------------------------------------------------
// Copyright (c) 2016 Nicolas Morand (https://twitter.com/NicolasGraph)
// -----------------------------------------------------------------------------

// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// -----------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// Table of contents
// -----------------------------------------------------------------------------
// 1. Settings     Where you can easily customize things!
// 2. CSS base     Don't you already set that?
// 3. Mixins
// 3.1 bpt         Mainly used by other mixins.
// 3.1 elsass        Generic resposive mixin.
// 3.2 children    Apply "elsass" mixin to defined children elements.
// 4. Functions    Exclusively used by mixins.
// 4.1 elsass
// 4.2 spacing
// 4.3 spacing-val
// 4.4 position
// 4.5 bpts

// -----------------------------------------------------------------------------
// 1. Settings
// -----------------------------------------------------------------------------

$settings: (
    "s": (                              // Each $settings key is used as a custom breakpoint.
        "content-max-width" : 480px,    // Max-width to optionally apply to containers.
        "vertical-spacing"  : 24px,     // Top and bottom gutters.
        "horizontal-spacing": 16px,     // Right and left gutters.
    ),
    "m": (
        "device-min-width"  : 640px, // Media-query min-width (useless for the first breakpoint).
        "content-max-width" : 800px,
        "vertical-spacing"  : 32px,
        "horizontal-spacing": 24px,
    ),
    "l": (
        "device-min-width"  : 1024px,
        "content-max-width" : 1000px,
        "vertical-spacing"  : 48px,
        "horizontal-spacing": 32px,
    ),
    "xl": (
        "device-min-width"  : 1440px,
        "content-max-width" : 1280px,
        "vertical-spacing"  : 54px,
        "horizontal-spacing": 48px,
    )
);

// -----------------------------------------------------------------------------
// 2. CSS base
// -----------------------------------------------------------------------------

html { box-sizing: border-box; }

*,
*:before,
*:after { box-sizing: inherit; }

// -----------------------------------------------------------------------------
// 3. Mixins
// -----------------------------------------------------------------------------

// 3.1 bpt
// -----------------------------------------------------------------------------
// Generate a media-query.
// @param  $from  breakpoint or min-width value;
// @param  $to    breakpoint or max-width value.
// -----------------------------------------------------------------------------
@mixin bpt($from: null, $to: null) {
    $mq: null;

    // Set a media-query min-width if $from is set and not the first breakpoint.
    @if $from and $from != nth(map-keys($settings), 1) {
        @if map-has-key($settings, $from) {
            // Get the breakpoint media-query min-width.
            $from-settings: map-get($settings, $from);
            $from: map-get($from-settings, "device-min-width");
        }
        $mq: "(min-width: #{$from})";
    }

    // Set a media-query max-width if needed.
    @if $to {
        @if map-has-key($settings, $to) {
            // Calculate the previous breakpoint max-width.
            $to-settings: map-get($settings, $to);
            $to: map-get($to-settings, "device-min-width") - 1;
        }
        $mq: if($mq, $mq " and (max-width: #{$to})", "(max-width: #{$to})");
    }

    // Wrap @content in a media query if set.
    @if $mq {
        @media screen and #{$mq} {
            @content;
        }
    } @else {
        @content;
    }
}

// 3.2 elsass
// -----------------------------------------------------------------------------
// Generate whatever responsive element you need.
// @param  $media       Breakpoint(s);
// @param  $flow        "flex-row", "flex-grid" or false;
// @param  $width       Ratio of the container width or true
//                      to generate a width of 100%
//                      and apply the breakpoint(s) related max-width;
//                      followed by the responsive max-width provided in $settings.
// @param  $gutter-in   Padding value(s) or ratio(s) of the breakpoint spacings;
// @param  $gutter-out  Margin value(s) or ratio(s) of the breakpoint spacings;
// @param  $position    "pull", "push", "center" or ratio of the container width.
// -----------------------------------------------------------------------------
@mixin elsass($media: null,
              $flow: null,
              $width: null,
              $gutter-in: null,
              $gutter-out: null,
              $position: null) {

    // Get the provided breakpoints.
    $bpts: map-keys($settings);
    $min-bpt: if(nth($media, 1), nth($media, 1), nth($bpts, 1));
    $max-bpt: if(type-of($media) == list, nth($media, 2), false);

    // List breakpoints explicitly and implicitly set.
    $bpts-set: bpts-set($min-bpt, $max-bpt);

    $css: (); // To store CSS properties and values per breakpoint.

    @each $bpt in $bpts-set {
        $bpt-css: (); // To store the current breakpoint CSS.

        $silent-gutter: null;
        $width-out: $gutter-out;
        @if type-of($gutter-out) == map and map-has-key($gutter-out, "silent")  {
            $width-out: map-get($gutter-out, "silent");
            $silent-gutter: true;
        }

        // Get and store CSS width related properties and values.
        @if $width {
            $width-max: $width;
            $max-width: null;
            @if $width == true {
                $width-max: 1;
                $max-width: true;
            };
            $bpt-width: width($bpt, $width-max, $max-width, $width-out);
            $bpt-css: map-merge($bpt-css, $bpt-width);
        }
        // Get and store CSS margin related properties and values.
        @if ($gutter-out and not $silent-gutter) or $position {
            $gutter: if($silent-gutter, false, $gutter-out);
            $bpt-css: map-merge($bpt-css, margin($bpt, $gutter, $position));
        }
        // Get and store CSS padding related properties and values.
        @if $gutter-in {
            $bpt-css: map-merge($bpt-css, padding($bpt, $gutter-in));
        }

        // Get and store CSS flex related properties and values.
        @if $flow {
            $direction: if($flow, nth($flow, 1), false);
            $wrap: if(type-of($flow) == list, nth($flow, 2), false);
            $bpt-css: map-merge($bpt-css, flex($direction, $wrap));
        }

        // Iterate breakpoint CSS to remove useless properties.
        @each $bpt-prop, $bpt-val in $bpt-css {
            // Iterate stored CSS per breakpoint.
            @each $stored-bpt, $stored-css in $css {
                @if map-has-key($stored-css, $bpt-prop) {
                    @if map-get($stored-css, $bpt-prop) == $bpt-val {
                        // Remove duplicated CSS.
                        $bpt-css: map-remove($bpt-css, $bpt-prop);
                    } @else {
                        // Re-merge CSS as it was maybe removed.
                        $bpt-css: map-merge($bpt-css, ($bpt-prop: $bpt-val));
                    }
                }
            }
        }

        // Store tidy breakpoint related CSS.
        $css: map-merge($css, ($bpt: $bpt-css));
    }

    // Generate CSS by iterating CSS per breakpoint.
    @each $stored-bpt, $stored-css in $css {
        @if $stored-bpt == nth($bpts-set, 1) {
            $to-bpt: nth($bpts-set, length($bpts-set));
            @include bpt($stored-bpt, if($max-bpt, $to-bpt, false)) {
                @each $prop, $val in map-get($css, $stored-bpt) {
                    #{$prop}: #{$val};
                }
                @content;
            }
            $css: if($max-bpt, map-remove($css, $to-bpt), $css);
        } @else {
            @include bpt($stored-bpt) {
                @each $prop, $val in map-get($css, $stored-bpt) {
                    #{$prop}: #{$val};
                }
            }
        }
    }
}

// -----------------------------------------------------------------------------
// 4. Functions
// -----------------------------------------------------------------------------

// 4.1 flex
// -----------------------------------------------------------------------------
// Returns a map of needed flex related CSS properties and their values.
// @param    $direction    CSS flex-direction value;
// @param    $wrap         CSS flex-wrap value;needed
// -----------------------------------------------------------------------------
@function flex($direction: null, $wrap: null) {
    $out: (); // Prepare the output.

    $out: map-merge($out, (display: flex));

    @if ($direction and $direction != row) and ($wrap and $wrap != nowrap) {
        $out: map-merge($out, (flex-flow: $direction $wrap));
    } @else if $direction and $direction != row {
        $out: map-merge($out, (flex-direction: $direction));
    } @else if $wrap and $wrap != nowrap {
        $out: map-merge($out, (flex-wrap: $wrap));
    }

    $out: map-merge($out, (" > * {" box-sizing: border-box "}"));

    @return $out;
}

// 4.2 width
// -----------------------------------------------------------------------------
// Returns a map of needed width related CSS properties and their values.
// @param  $bpt         Breakpoint as a $settings key;
// @param  $width       Width value or ratio of the container width;
// @param  $max-width   Max width value or true to use the breakpoint settings;
// @param  $gutter-out  Margin value(s) or ratio(s) of the breakpoint spacings;
// -----------------------------------------------------------------------------
@function width($bpt, $width, $max-width: null, $gutter-out: null) {
    $out: ();
    $min-settings: map-get($settings, $bpt);
    $width-out: null;

    @if $gutter-out {
        $margin: spacing($bpt, $gutter-out);

        $right: map-get($margin, "right");
        @if $right and $right != 0 {
            $width-out: $right;
        }

        $left: map-get($margin, "left");
        @if $left and $left != 0 {
            @if $width-out {
                $width-out: $width-out + $left;
            } @else {
                $width-out: $left;
            }
        }
    }

    // Soustract gutters from CSS width and max-width if needed.
    @if $width-out {
        $abs-factor: abs($width-out);

        @if $width {
            $width: if(unitless($width), percentage($width), $width);
            $comparable: comparable($width, $width-out);
            $calc-width: null;
            @if $comparable {
                @if $width-out == $abs-factor {
                    $calc-width: $width - $abs-factor;
                } @else {
                    $calc-width: $width + $abs-factor;
                }
            } @else {
                @warn "width is using calc().";
                @if $width-out == $abs-factor {
                    $calc-width: calc(#{$width} - #{$abs-factor});
                } @else {
                    $calc-width: calc(#{$width} + #{$abs-factor});
                }
            }
            $out: map-merge($out, (width: $calc-width));
        }

        @if $max-width {
            $max-width: map-get($min-settings, "content-max-width");
            $comparable: comparable($max-width, $width-out);
            $calc-max: null;
            @if $comparable {
                @if $width-out == $abs-factor {
                    $calc-max: $max-width - $abs-factor;
                } @else {
                    $calc-max: $max-width + $abs-factor;
                }
            } @else {
                @warn "max-width is using calc().";
                @if $width-out == $abs-factor {
                    $calc-max: calc(#{$max-width} - #{$abs-factor});
                } @else {
                    $calc-max: calc(#{$max-width} + #{$abs-factor});
                }
            }
            $out: map-merge($out, (max-width: $calc-max));
        }
    } @else {
        $out: map-merge($out, (width: $width));
        $out: map-merge($out, (max-width: $max-width));
    }
    @return $out;
}

// 4.3 padding
// -----------------------------------------------------------------------------
// Returns a map of padding related CSS properties and their values.
// @param  $bpt        Breakpoint as a $settings key;
// @param  $gutter-in  Padding value(s) or ratio(s) of the breakpoint spacings.
// -----------------------------------------------------------------------------
@function padding($bpt, $gutter-in) {
    // Get a map of padding values.
    $padding: spacing($bpt, $gutter-in);

    $out: (); // Prepare the output.
    // Get the padding shorthand or each margin side value.
    @if map-has-key($padding, "global") {
        $out: map-merge($out, (padding: map-get($padding, "global")));
    } @else {
        @each $side, $val in $padding {
            $out: map-merge($out, (padding-#{$side}: $val));
        }
    }

    @return $out;
}

// 4.4 margin
// -----------------------------------------------------------------------------
// Returns a map of margin related CSS properties and their values.
// @param  $bpt         Breakpoint as a $settings key;
// @param  $gutter-out  Margin value(s) or ratio(s) of the breakpoint spacings.
// -----------------------------------------------------------------------------
@function margin($bpt, $gutter-out, $position: null) {
    // Get a map of margin values.
    $margin: spacing($bpt, $gutter-out);

    // Alterate the $margin map values with $position.
    @if $position {
        $margin: position($margin, $position);
    }

    $out: (); // Prepare the output.
    // Get the margin shorthand or each margin side value.
    @if map-has-key($margin, "global") {
        $out: map-merge($out, (margin: map-get($margin, "global")));
    } @else {
        @each $side, $val in $margin {
            $out: map-merge($out, (margin-#{$side}: $val));
        }
    }

    @return $out;
}

// 4.5 spacing
// -----------------------------------------------------------------------------
// Return a map of spacing values from $spacing.
// @param  $bpt      Breakpoint as a $settings key;
// @param  $spacing  Margin/padding value(s) or ratio(s) of the breakpoint spacings.
// -----------------------------------------------------------------------------
@function spacing($bpt, $spacing) {
    // Get the breakpoint related spacing values as a calculation base.
    $min-settings: map-get($settings, $bpt);
    $base: map-get($min-settings, "vertical-spacing");
    $base: $base map-get($min-settings, "horizontal-spacing");

    // Set each side margin.
    $sides: "top", "right", "bottom", "left";

    @if type-of($spacing) == map {
        $new-spacing: null;
        @each $side in $sides {
            @if map-has-key($spacing, $side) {
                $val: map-get($spacing, $side);
                $new-spacing: if($new-spacing == null, $val, append($new-spacing, $val));
            } @else {
                $new-spacing: if($new-spacing == null, false, append($new-spacing, false));
            }
        }
        $spacing: $new-spacing;
    } @else if type-of($spacing) == list and length($spacing) == 2 {
        $spacing: nth($spacing, 1) nth($spacing, 2) nth($spacing, 1) nth($spacing, 2);
    } @else if type-of($spacing) != list {
        $spacing: $spacing $spacing $spacing $spacing;
    }

    $spacings: ();

    @for $i from 1 through length($spacing) {
        $val: nth($spacing, $i);
        @if $val != false {
            // Get the CSS value.
            $base-i: if($i == 1 or $i == 3, nth($base, 1), nth($base, 2));
            $spacing-val: spacing-val($base-i, $val);
            // Build the map.
            $spacings: map-merge($spacings, (#{nth($sides, $i)}: $spacing-val));
        }
    }

    // Set a margin shorthand if possible.
    $top: map-get($spacings, "top");
    $right: map-get($spacings, "right");
    $bottom: map-get($spacings, "bottom");
    $left: map-get($spacings, "left");

    @if $top and $top == $bottom and $right and $right == $left {
        @if $top == $right {
            $spacings: map-merge($spacings, ("global": $top));
        } @else {
            $spacings: map-merge($spacings, ("global": $top $right));
        }
    }

    @return $spacings;
}

// 4.6 spacing-val
// -----------------------------------------------------------------------------
// Return a css value.
// @param  $base  A CSS value used as a calculation base;
// @param  $val   A $spacing value.
// -----------------------------------------------------------------------------
@function spacing-val($base: null, $val: null) {
    $spacing: null;

    @if $val == "nested" {
        $spacing: (-($base)); // Use $base as a negative val.
    } @else if type-of($val) == number and unitless($val) {
        $spacing: if($val == 0, $val, $val * ($base)); // Multiply the $base val.
    } @else {
        $spacing: $val; // Use a custom spacing value.
    }

    @return $spacing;
}

// 4.7 position
// -----------------------------------------------------------------------------
// Atlterate margins according to the $position value.
// @param   $margin    Map returned by spacing(),
// @param   $position  Mixin argument.
// -----------------------------------------------------------------------------
@function position($margin, $position) {
    $side: null;
    $val: null;

    @if $position == "center" {
        $margin: map-merge($margin, ("right": auto, "left": auto));
        // Set or reset a margin shorthand if possible.
        $margin-top: map-get($margin, "top");
        @if $margin-top and $margin-top == map-get($margin, "bottom") {
            $global: if($margin-top == "auto", auto, $margin-top auto);
            $margin: map-merge($margin, ("global": $global));
        }
    } @else {
        // Margin shorthand won't be useful anymore.
        @if map-has-key($margin, "global") {
            $margin: map-remove($margin, "global");
        }
        @if $position == "pull" {
            $margin: map-merge($margin, ("right": auto));
        } @else if $position == "push" {
            $margin: map-merge($margin, ("left": auto));
        } @else if type-of($position) == number {
            // Prepare $position to be added, or soustracted if negative.
            $operator: if($position == abs($position), "+", "-");
            $position: percentage(abs($position));
            // Set the margin-left value.
            $out: map-get($margin, "left");
            @if $out and $out != 0 {
                $val: calc(#{$out} #{$operator} #{$position});
            } @else {
                $val: #{$operator}$position;
            }
            $margin: map-merge($margin, ("left": #{$val}));
        }
    }

    @return $margin;
}

// 4.8 bpts
// -----------------------------------------------------------------------------
// Returns a list of breakpoints explicitly or implicitly set in the elsass mixin.
// @param   $from  Breakpoint;
// @param   $to    Breakpoint.
// -----------------------------------------------------------------------------
@function bpts-set($from: null, $to: null) {
    // Get the position of each breakpoint in the $settings map.
    $bpts: map-keys($settings);
    $from: if($from, index($bpts, $from), 1);
    $to: if($to, index($bpts, $to), length($bpts));

    $out: null; // Prepare the output.
    // Get a list of the breakpoints set explicitly and implicitly.
    @for $i from $from through $to {
        $bpt: nth($bpts, $i);
        $out: if($out, append($out, $bpt), $bpt);
    }

    @return $out;
}
