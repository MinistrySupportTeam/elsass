// Copyright (c) 2016 Nicolas Morand (https://twitter.com/NicolasGraph)

// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// ------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// 1. Settings
// ===========
// 1.1 Layout variables
// 1.2 Layout constants
// 1.3 Default mixin argument values

// 2. CSS base
// ===========

// 3. Mixins
// =========
// 3.1 _el-bpt
// 3.2 el-sass

// 4. Functions
// ============
// 4.1 el-sass
// 4.2 el-flex
// 4.3 el-width
// 4.4 el-padding
// 4.5 el-margin
// 4.6 _el-shift
// 4.7 _el-gap
// 4.8 _el-gap-shorthand
// 4.9 _el-bpts-set
// 4.10 _el-check

// 1. Settings
// ===========

// 1.1 Layout variables
// --------------------
$settings: (
  's': (                          // Each key is a custom breakpoint.
    'container-max-width': 480px, // Max-width to optionally apply to containers.
    'gutter-height'      : 24px,
    'gutter-width'       : 16px,
  ),
  'm': (
    'device-min-width'   : 640px, // Media-query min-width (useless for the first breakpoint).
    'container-max-width': 800px,
    'gutter-height'      : 32px,
    'gutter-width'       : 24px,
  ),
  'l': (
    'device-min-width'   : 1024px,
    'container-max-width': 1000px,
    'gutter-height'      : 40px,
    'gutter-width'       : 32px,
  ),
  'xl': (
    'device-min-width'   : 1440px,
    'container-max-width': 1280px,
    'gutter-height'      : 48px,
    'gutter-width'       : 40px,
  )
) !default;

// 1.2 Layout constants -> Keep this untouched!
// --------------------
$BPTS: map-keys($settings); // Breakpoints list.
$BPT-MIN: nth($BPTS, 1);  // Smallest breakpoint.

// 1.3 Default mixin argument values
// ---------------------------------
$el-sass: (
  'media'     : $BPT-MIN,
  'flow'      : row wrap,
  'width'     : 'max',
  'gutter-in' : .5,
  'gutter-out': .5,
  'shift'     : null,
) !default;

// 2. CSS base
// ===========

html { box-sizing: border-box; }

*,
*:before,
*:after { box-sizing: inherit; }

// 3. Mixins
// =========

// 3.1 _el-bpt
// -----------
// Generate a media-query.
// @param  $from  breakpoint or min-width value;
// @param  $to    breakpoint or max-width value.
// @see    3.2 elsass
@mixin _el-bpt($from: null, $to: null) {
  $mq: null; // Media-query

  // Set a media-query min-width if $from is set
  // and not the first breakpoint.
  @if $from and $from != $BPT-MIN {
    @if map-has-key($settings, $from) {
      $from-settings: map-get($settings, $from);
      $from: map-get($from-settings, 'device-min-width');
    }
    $mq: '(min-width: #{$from})';
  }

  // Set a media-query max-width if needed.
  @if $to {
    @if map-has-key($settings, $to) {
      $to-settings: map-get($settings, $to);
      $to: map-get($to-settings, 'device-min-width') - 1;
    }
    $mq: if($mq, $mq ' and (max-width: #{$to})', '(max-width: #{$to})');
  }

  // Wrap @content in a media query if set.
  @if $mq {
    @media screen and #{$mq} {
      @content;
    }
  } @else {
    @content;
  }
}

// 3.2 el-sass
// -----------
// Generate whatever responsive element you need.
// @param  $media       Breakpoint(s);
// @param  $flow        flex-direction flex-wrap;
// @param  $width       Ratio of the container width or true
//                      to generate a width of 100%
//                      and apply the breakpoint(s) related max-width;
//                      followed by the responsive max-width provided in $settings.
// @param  $gutter-in   Padding value(s) or ratio(s) of the breakpoint gaps;
// @param  $gutter-out  Margin value(s) or ratio(s) of the breakpoint gaps;
// @param  $shift    'pull', 'push', 'center' or ratio of the container width.
@mixin el-sass(
  $media     : null,
  $flow      : null,
  $width     : null,
  $gutter-in : null,
  $gutter-out: null,
  $shift     : null
) {

  // Set/reset arguments according to values/default values.
  $args: (
    'media'     : $media,
    'flow'      : $flow,
    'width'     : $width,
    'gutter-in' : $gutter-in,
    'gutter-out': $gutter-out,
    'shift'     : $shift,
  );

  $default: null;

  @each $arg, $val in $args {
    @if ($val == true or $val == '…') or ($val == null and $default) {
      $args: map-merge($args, ($arg: map-get($el-sass, $arg)));
      @if not $default and $val == '…' {
        $default: true;
      }
    }
  }

  $check: _el-check($args...);

  // Get the provided breakpoints.
  $media: map-get($args, 'media');
  $bpt-min: if(nth($media, 1), nth($media, 1), $BPT-MIN);
  $bpt-max: if(type-of($media) == list, nth($media, 2), false);

  // Wrap the CSS content in a media-query.
  @include _el-bpt($bpt-min, $bpt-max) {
    @content;
  }

  // Wrap each breakpoint related rules in dedicated media-queries.
  @if map-remove($args, 'media') != () {
    $css: el-sass($args...);
    @each $bpt-min, $to-map in $css {
      @each $bpt-max, $bpt-css in $to-map {
        @include _el-bpt($bpt-min, $bpt-max) {
          @each $prop, $val in $bpt-css {
            #{$prop}: #{$val};
          }
        }
      }
    }
  }
}

// 4. Functions
// ============

// 4.1 el-sass
// -----------
// Returns a map of needed CSS properties
// and their values from elsass mixin arguments.
// @see  3.2 elsass
@function el-sass(
  $media     : null,
  $flow      : null,
  $width     : null,
  $gutter-in : null,
  $gutter-out: null,
  $shift     : null
) {

  // Get breakpoints.
  $bpt-min: if(nth($media, 1), nth($media, 1), $BPT-MIN);
  $bpt-max: if(type-of($media) == list, nth($media, 2), false);

  // List breakpoints explicitly and implicitly set.
  $bpts-set: _el-bpts-set($bpt-min, $bpt-max);

  $out: (); // To store CSS properties and values per breakpoint.

  @each $bpt in $bpts-set {
    $i: index($bpts-set, $bpt);
    $bpt-next: null;

    // Get the next breakpoint.
    @if $i == length($bpts-set) {
      $bpt-next: if($bpt-max, nth($BPTS, index($BPTS, $bpt) + 1), false);
    } @else {
      $bpt-next: nth($bpts-set, $i + 1);
    }

    $bpt-css: (); // To store the current breakpoint CSS.

    // Get and store CSS width related properties and values.
    @if $width {
      $width-out: $gutter-out;
      @if $gutter-out == 'silent' {
        $width-out: map-get($el-sass, 'gutter-out');
      } @else if type-of($gutter-out) == map and
                 map-has-key($gutter-out, 'silent') {
        $width-out: map-get($gutter-out, 'silent');
      }
      $bpt-width: null;
      @if $width == 'max' {
        $bpt-width: el-width($bpt, 1, true, $width-out);
      } @else {
        $bpt-width: el-width($bpt, $width, false, $width-out);
      }
      $bpt-css: map-merge($bpt-css, $bpt-width);
    }

    // Get and store CSS margin related properties and values.
    @if $gutter-out {
      $bpt-css: map-merge($bpt-css, el-margin($bpt, $gutter-out, $shift));
    }

    // Get and store CSS padding related properties and values.
    @if $gutter-in {
      $bpt-css: map-merge($bpt-css, el-padding($bpt, $gutter-in));
    }

    // Get and store CSS flex related properties and values.
    @if $flow {
      $dir: if($flow, nth($flow, 1), false);
      $wrap: if(type-of($flow) == list, nth($flow, 2), false);
      $bpt-css: map-merge($bpt-css, el-flex($dir, $wrap));
    }

    // Reduce and store each breakpoint related CSS.
    @if $out == () {
      $out: ($bpt: ($bpt-next: $bpt-css));
    } @else {
      $new-css: ();
      @each $prop, $val in $bpt-css {
        @each $bpt-min, $to-map in $out {
          @if map-has-key($to-map, $bpt) {
            $to-css: map-get($to-map, $bpt);
            @if map-get($to-css, $prop) == $val {
              // Remove duplicated CSS.
              $bpt-css: map-remove($bpt-css, $prop);
              $to-css: map-remove($to-css, $prop);
              // Store duplicated CSS.
              $new-css: map-merge($new-css, ($prop: $val));
              // Merge
              $new-to-map: ($bpt: $to-css, $bpt-next: $new-css);
              $to-map: map-merge(map-get($out, $bpt-min), $new-to-map);
              $out: map-merge($out, ($bpt-min: ($to-map)));
            }
            $out: map-merge($out, ($bpt: ($bpt-next: $bpt-css)));
          }
        }
      }
    }
  }

  @return $out;
}

// 4.2 el-flex
// -----------
// Returns a map of needed flex related CSS properties and their values.
// @param  $dir   CSS flex-direction value;
// @param  $wrap  CSS flex-wrap value;
// @see    3.2 elsass
@function el-flex($dir: null, $wrap: null) {
  $out: (display: flex); // Prepare the output.

  @if ($dir and $dir != row) and ($wrap and $wrap != nowrap) {
    $out: map-merge($out, (flex-flow: $dir $wrap));
  } @else if $dir and $dir != row {
    $out: map-merge($out, (flex-direction: $dir));
  } @else if $wrap and $wrap != nowrap {
    $out: map-merge($out, (flex-wrap: $wrap));
  }

  @return $out;
}

// 4.3 el-width
// ------------
// Returns a map of needed width related CSS properties and their values.
// @param  $bpt         Breakpoint as a $settings key;
// @param  $width       Width value or ratio of the container width;
// @param  $max-width   Max width value or true to use the breakpoint settings;
// @param  $gutter-out  Margin value(s) or ratio(s) of the breakpoint gaps;
// @see    3.2 elsass
@function el-width($bpt, $width, $max-width: null, $gutter-out: null) {
  $width-out: null;
  $abs-out: null;

  // Get a margin value to subtract.
  @if ($width or $max-width) and $gutter-out {
    $margin: _el-gap($bpt, $gutter-out);
    $right: map-get($margin, 'right');
    @if $right and $right != 0 {
      $width-out: $right;
    }
    $left: map-get($margin, 'left');
    @if $left and $left != 0 {
      $width-out: if($width-out, $width-out + $left, $left);
    }
    $abs-out: if($width-out, abs($width-out), null);
  }

  @if $width and unitless($width) {
    $width: percentage($width);
  }

  @if $max-width == true {
    $max-width: map-get(map-get($settings, $bpt), 'container-max-width');
  }

  $out: ();
  // Calculate width and max-width values according to margins.
  @each $prop, $val in (width: $width, max-width: $max-width) {
    @if $val {
      @if $width-out {
        $calc: null;
        @if comparable($val, $width-out) {
          $calc: if($width-out == $abs-out, $val - $abs-out, $val + $abs-out);
        } @else {
          @warn 'Using calc() as CSS value for' + #{$prop};
          $operator: if($width-out == $abs-out, '-', '+');
          $calc: calc(#{$val} #{$operator} #{$abs-out});
        }
        $out: map-merge($out, (#{$prop}: $calc));
      } @else {
        $out: map-merge($out, (#{$prop}: $val));
      }
    }
  }

  @return $out;
}

// 4.4 el-padding
// --------------
// Returns a map of padding related CSS properties and their values.
// @param  $bpt     Breakpoint as a $settings key;
// @param  $gutter  Padding value(s) or ratio(s) of the breakpoint gaps.
// @see    3.2 elsass
@function el-padding($bpt, $gutter) {
  // Get a map of padding values per side.
  $padding: _el-gap-shorthand(_el-gap($bpt, $gutter));

  $out: ();
  // Get the padding shorthand or each margin side value.
  @if map-has-key($padding, 'global') {
    $out: map-merge($out, (padding: map-get($padding, 'global')));
  } @else {
    @each $side, $val in $padding {
      $out: map-merge($out, (padding-#{$side}: $val));
    }
  }

  @return $out;
}

// 4.5 el-margin
// -------------
// Returns a map of margin related CSS properties and their values.
// @param  $bpt     Breakpoint as a $settings key;
// @param  $gutter  Margin value(s) or ratio(s) of the breakpoint gaps.
// @see    3.2 elsass
@function el-margin($bpt, $gutter, $shift: null) {
  // Prepare silent gutter variables.
  $silent: null;

  @if $gutter == 'silent' or
     (type-of($gutter) == map and map-has-key($gutter, 'silent')) {
    $silent: true;
    @if $gutter == 'silent' {
      $gutter: map-get($el-sass, 'gutter-out');
    } @else {
      $gutter: map-get($gutter, 'silent');
    }
  }

  // Get a map of margin values per side.
  $margin: _el-gap($bpt, $gutter);

  // Alterate $margin according to $shift.
  @if $shift {
    $shift: _el-shift($margin, $shift);
    $margin: if($silent, $shift, map-merge($margin, $shift));
  }

  // Get a margin shorthand if possible.
  $margin: _el-gap-shorthand($margin);

  $out: ();
  // Get the margin shorthand or each margin side value.
  @if map-has-key($margin, 'global') {
    $out: map-merge($out, (margin: map-get($margin, 'global')));
  } @else {
    @each $side, $val in $margin {
      $out: map-merge($out, (margin-#{$side}: $val));
    }
  }

  @return $out;
}

// 4.6 _el-shift
// -------------
// Atlterate margins according to the $shift value.
// @param  $margin    Margins map as returned by _el-gap(),
// @param  $shift  elsass mixin argument.
// @see    3.2 elsass
@function _el-shift($margin, $shift) {
  $shifts: ();

  @if type-of(nth($shift, 1)) == number {
    $shift-left: percentage(nth($shift, 1));
    $shifts: map-merge($shifts, ('left': $shift-left));
    @if type-of($shift) != list {
      $shifts: map-merge($shifts, ('right': -$shift-left));
    }
  } @else if $shift == 'center' or $shift == 'pull' or $shift == 'push' {
    @if $shift == 'center' or $shift == 'pull' {
      $shifts: map-merge($shifts, ('right': auto));
    }
    @if $shift == 'center' or $shift == 'push' {
      $shifts: map-merge($shifts, ('left': auto));
    }
  }

  $out: ();

  @each $side, $shift in $shifts {
    @if $shift {
      $val: $shift;
      @if type-of($shift) == number {
        $gap: map-get($margin, #{$side});
        $abs: abs($shift);
        // Calculate the new left margin value directly or via calc().
        @if comparable($gap, $shift) {
          $val: if($shift == $abs, $gap + $abs, $gap - $abs);
        } @else {
          @warn 'Using calc() as CSS value for margin-#{$side}.';
          $o: if($shift == $abs, '+', '-');
          $val: calc(#{$gap} #{$o} #{$abs});
        }
      }
      $out: map-merge($out, (#{$side}: $val));
    }
  }

  @return $out;
}

// 4.7 _el-gap
// -----------
// Return a map of gap values from $gap.
// @param  $bpt  Breakpoint;
// @param  $gap  Margin/padding value(s) or ratio(s) of the breakpoint gaps.
// @see    4.3 el-padding, 4.4 el-margin
@function _el-gap($bpt, $gap) {
  // Get $gap as a four values list.
  $sides: 'top', 'right', 'bottom', 'left';

  @if type-of($gap) == number {
    $gap: $gap $gap $gap $gap;
  } @else if type-of($gap) == list and length($gap) == 2 {
    $gap: nth($gap, 1) nth($gap, 2) nth($gap, 1) nth($gap, 2);
  } @else if type-of($gap) == map {
    $new-gap: null;
    @each $side in $sides {
      $val: if(map-has-key($gap, $side), map-get($gap, $side), false);
      $new-gap: if($new-gap == null, $val, append($new-gap, $val));
    }
    $gap: $new-gap;
  }

  $out: (); // To store each gap side and its value.
  // Set each gap side value.
  @for $i from 1 through length($gap) {
    $val: nth($gap, $i);
    @if $val != false {
      @if unitless($val) {
        $bpt-settings: map-get($settings, $bpt);
        @if ($i == 1 or $i == 3) {
          $val: $val * map-get($bpt-settings, 'gutter-height');
        } @else {
          $val: $val * map-get($bpt-settings, 'gutter-width');
        }
      }
      $out: map-merge($out, (#{nth($sides, $i)}: $val));
    }
  }

  @return $out;
}

// 4.8 _el-gap-shorthand
// ---------------------
// Return a map of gap values from $gap.
// @param  $gap  Margin/padding value(s) or ratio(s) of the breakpoint gaps.
// @see    4.9 _el-gap
@function _el-gap-shorthand($gap) {
  // Set a gap shorthand if possible.
  $top: map-get($gap, 'top');
  $right: map-get($gap, 'right');

  @if $top and $top == map-get($gap, 'bottom') and
    $right and $right == map-get($gap, 'left') {
    $global: if($top == $right, $top, $top $right);
    $gap: map-merge($gap, ('global': $global));
  }

  @return $gap;
}

// 4.9 _el-bpts-set
// ----------------
// Returns a list of breakpoints.
// @param  $from  Breakpoint;
// @param  $to    Breakpoint.
// @see    3.2 elsass
@function _el-bpts-set($from: null, $to: null) {
  // Get the shift of each breakpoint in the $settings map.
  $bpt-min: if($from, index($BPTS, $from), 1);
  $bpt-max: if($to, index($BPTS, $to), length($BPTS));

  $out: null; // Prepare the output.
  // Get a list of explicitly and implicitly breakpoints set.
  @for $i from $bpt-min through $bpt-max {
    @if not $to or $i != index($BPTS, $to) {
      $bpt: nth($BPTS, $i);
      $out: if($out, append($out, $bpt), $bpt);
    }
  }

  @return $out;
}

// 4.10 _el-check
// --------------
// Return an error message if an argument value is not valid.
// @see  ## el-sass
@function _el-check(
  $media     : null,
  $flow      : null,
  $width     : null,
  $gutter-in : null,
  $gutter-out: null,
  $shift     : null
) {

  @if $media {
    $min: nth($media, 1);
    $max: if(type-of($media) == list, nth($media, 2), false);
    @if (type-of($media) == list and length($media) > 2) or
        ($min and not map-has-key($settings, $min) and type-of($min) != number) or
        ($max and not map-has-key($settings, $max) and type-of($max) != number) {
      @error '#{&}: "#{$media}" is not a valid value for $media.';
    }
  }

  @if $width and $width != 'max' and type-of($width) != number {
    @error '#{&}: "#{$width}" is not a valid value for $width.';
  }

  @if $flow {
    $dir: nth($flow, 1);
    $wrap: if(type-of($flow) == list, nth($flow, 2), false);
    @if (type-of($flow) == list and length($flow) > 2) or
        ($dir and $dir != column and $dir != row and $dir != row-reverse) or
        ($wrap and $wrap != nowrap and $wrap != wrap and $wrap != wrap-reverse) {
      @error '#{&}: "#{$flow}" is not a valid value for $flow.';
    }
  }

  $gutters: (
    'gutter-in' : $gutter-in,
    'gutter-out': $gutter-out,
  );

  @each $gutter, $vals in $gutters {
    $vals-type: type-of($vals);
    @if $vals {
      @if $vals-type == list {
        @if length($vals) != 2 and length($vals) != 4 {
          @error '#{&}: "#{$vals}" is not a valid value for $#{$gutter}.';
        } @else {
          @each $val in $vals {
            @if $val and type-of($val) != number {
              @error '#{&}: "#{$vals}" is not a valid value for $#{$gutter}.';
            }
          }
        }
      } @else if $vals-type != number and ($gutter == 'gutter-out' and $vals != 'silent') {
        @error '#{&}: "#{$vals}" is not a valid value for $#{$gutter}.';
      }
    }
  }

  @if $shift {
    $to: nth($shift, 1);
    $next: if(type-of($shift) == list, nth($shift, 2), false);
    @if (type-of($shift) == list and length($shift) > 2) or
        ($to != 'push' and $to != 'center' and ($next and type-of($to) != number)) or
        $next and (($to > 0 and $next != 'push-next') or ($to < 0 and $next != 'pull-next')) {
      @error '#{&}: "#{$shift}" is not a valid value for $shift.';
    }
  }

  @return true;
}
