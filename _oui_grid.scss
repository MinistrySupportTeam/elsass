// -----------------------------------------------------------------------------
// Copyright (c) 2016 Nicolas Morand (https://github.com/NicolasGraph)
// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// -----------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// -----------------------------------------------------------------------------
// 1. Settings
// 2. CSS base
// 3. Variables
// 4. Mixins
// 5. Functions
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// 1. Settings
// -----------------------------------------------------------------------------

$settings: (
    "s": (                           // Each key is used as a bpt.
        "content-max-width" : 480px, // Max-width to optionally apply to containers.
        "vertical-gap"  : 12px,  // Top and bottom gutters.
        "horizontal-gap": 8px    // Right and left gutters.
    ),
    "m": (
        "device-min-width"  : 640px, // Media-query min-width.
        "content-max-width" : 800px,
        "vertical-gap"  : 16px,
        "horizontal-gap": 12px
    ),
    "l": (
        "device-min-width"  : 1024px,
        "content-max-width" : 1000px,
        "vertical-gap"  : 24px,
        "horizontal-gap": 16px
    ),
    "xl": (
        "device-min-width"  : 1440px,
        "content-max-width" : 1280px,
        "vertical-gap"  : 32px,
        "horizontal-gap": 24px
    )
);

// -----------------------------------------------------------------------------
// 2. CSS base
// -----------------------------------------------------------------------------

html { box-sizing: border-box; }

html * { box-sizing: inherit; }

// -----------------------------------------------------------------------------
// 3. Variables
// -----------------------------------------------------------------------------

$bpts: map-keys($settings);

// -----------------------------------------------------------------------------
// 4. Mixins
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Generate a media-query.
// @param    $min    A $settings key or a CSS min-width val;
// @param    $max    A $settings key or a CSS max-width val;
// -----------------------------------------------------------------------------
@mixin bpt($min: null, $max: null) {
    $media-query: null;

    @if $min {
        // If $min is a $settings key; get the related val if it exists.
        @if map-has-key($settings, $min) {
            $min-settings: map-get($settings, $min);
            @if map-has-key($min-settings, "device-min-width") {
                $min: map-get($min-settings, "device-min-width");
            } @else {
                $min: null;
            }
        }
        // Set the media-query min-width if defined.
        $media-query: if($min, "(min-width: #{$min})", null);
    }

    @if $max {
        // If $max is a $settings key; get the related val.
        @if map-has-key($settings, $max) {
            $max-settings: map-get($settings, $max);
            $max: map-get($max-settings, "device-min-width") - 1;
        }
        // Add or set the media-query max-width.
        @if $min {
            $media-query: $media-query " and (max-width: #{$max})";
        } @else {
            $media-query: "(max-width: #{$max})";
        }
    }

    // Generate the CSS media-query if it exists.
    @if $media-query {
        @media screen and #{$media-query} {
            @content;
        }
    } @else {
        @content;
    }
}

// -----------------------------------------------------------------------------
// Generate a responsive item.
// @param    $media    $settings key(s) used as the media-query min-width and/or max-width;
// @param    $flow     "row" or "grid";
// @param    $width    A fraction or a factor of the container width,
//                     "max-width" can also be used to generate a width of 100%
//                     and following by a responsive max-width as provided in settings.
// @param    $margin   A;
// @param    $position     "row" or "grid";
// @param    $padding     "row" or "grid";
// -----------------------------------------------------------------------------
@mixin item($media: null, $flow: null, $width: null, $margin: null, $position: null, $padding: null) {

    // List in use breakpoints from $media.
    $min-bpt: null;
    $max-bpt: null;

    @if $media {
        $min-bpt: if(nth($media, 1), nth($media, 1), null);
        $max-bpt: if(type-of($media) == list, nth($media, 2), null);
    }

    $bpts: bpts($min-bpt, $max-bpt);

    @if $bpts {

        $css: ();
        $first: true;

        @each $bpt in $bpts {
            // Get CSS properties and their vals.
            $bpt-css: item($bpt, $flow, $width, $margin, $position, $padding);
            // Remove useless repeated vals.
            @each $bpt-prop, $bpt-val in $bpt-css {
                @each $stored-bpt, $stored-css in $css {
                    @if map-has-key($stored-css, $bpt-prop) {
                        @if map-get($stored-css, $bpt-prop) == $bpt-val {
                            $bpt-css: map-remove($bpt-css, $bpt-prop);
                        } @else {
                            $bpt-css: map-merge($bpt-css, ($bpt-prop: $bpt-val));
                        }
                    }
                }
            }
            // Store CSS properties and their vals.
            $css: map-merge($css, ($bpt: $bpt-css));
        }
        // Generate CSS.
        @each $stored-bpt, $stored-css in $css {
            @if $stored-bpt == nth($bpts, 1) {
            @include bpt($stored-bpt, nth($bpts, length($bpts))) {
                @each $prop, $val in map-get($css, $stored-bpt) {
                    #{$prop}: $val;
                }
                    @content;
                }
            } @else {
                @include bpt($stored-bpt) {
                    @each $prop, $val in map-get($css, $stored-bpt) {
                        #{$prop}: $val;
                    }
                }
            }
        }
    }
}

@function item($media: null, $flow: null, $width: null, $margin: null, $position: null, $padding: null) {

    // Set a map to store the generated css properties and their vals.
    $css : ();

    // Get the media-query related vals.
    $min-settings: null;
    $min-width: null;
    $max-width: null;

    @if $media {
        @if nth($media, 1) {
            $min-settings: map-get($settings, nth($media, 1));
        } @else {
            $min-settings: map-get($settings, "s");
        }
    } @else {
        $min-settings: map-get($settings, "s");
    }

    // Set the display and flex-wrap properties from $flow.
    @if $flow {
        $css: map-merge($css, (display: flex));
        @if $flow == "flex-grid" {
            $css: map-merge($css, (flex-wrap: wrap));
        }
    }

    // Set the margins properties from $margin and $position.
    $gap-x: map-get($min-settings, "horizontal-gap");
    $gap-y: map-get($min-settings, "vertical-gap");

    $css-margins: null;
    $css-positions: null;

    @if $margin {
        // Make $margin a four items list.
        @if type-of($margin) == list {
            @if length($margin) == 2 {
                $margin: nth($margin, 1) nth($margin, 2) nth($margin, 1) nth($margin, 2);
            }
        } @else {
            $margin: $margin $margin $margin $margin;
        }
        // Get the a map of CSS margins.
        $css-margins: gap($gap-y, $gap-x, $margin);
        $css-positions: $css-margins;
        @if $position {
            // Alterate margins width $position.
            $css-positions: position($css-positions, $position);
        }
        // Use the margin shorthand or store each side val.
        @if map-has-key($css-positions, "global") {
            $css: map-merge($css, (margin: map-get($css-positions, "global")));
        } @else {
            @each $side, $val in $css-positions {
                $css: map-merge($css, (margin-#{$side}: $val));
            }
        }
    }

    // Set the paddings properties from $padding.
    @if $padding {
        $css-paddings: null;
        // Make $padding a four items list.
        @if type-of($padding) == list {
            @if length($padding) == 2 {
                $padding: nth($padding, 1) nth($padding, 2) nth($padding, 1) nth($padding, 2);
            }
        } @else {
            $padding: $padding $padding $padding $padding;
        }
        // Get the a map of CSS paddings.
        $css-paddings: gap($gap-y, $gap-x, $padding);
        // Use the padding shorthand or store each side val.
        @if map-has-key($css-paddings, "global") {
            $css: map-merge($css, (padding: map-get($css-paddings, "global")));
        } @else {
            @each $side, $val in $css-paddings {
                $css: map-merge($css, (padding-#{$side}: $val));
            }
        }
    }

    // Set the width and max-width properties from $width and $margin.
    @if $width {
        // Set the margin val to soustract from the width.
        $margin-factor: null;
        @if $margin {
            @if map-get($css-margins, "right") and map-get($css-margins, "right") != 0 {
                $margin-factor: map-get($css-margins, "right");
            }
            @if map-get($css-margins, "left") and map-get($css-margins, "left") != 0 {
                @if $margin-factor {
                    $margin-factor: $margin-factor + map-get($css-margins, "left");
                } @else {
                    $margin-factor: map-get($css-margins, "left");
                }
            }
        }

        // Set the max-width val.
        $content-max-width: null;
        $val: null;
        @if $width == "max-width" {
            $val: 100%;
            $content-max-width: map-get($min-settings, "content-max-width");
        } @else {
            $val: $width * 100%;
        }

        $css: map-merge($css, (width: if($margin-factor, calc(#{$val} - #{$margin-factor}), #{$val})));
        $css: map-merge($css, (max-width: $content-max-width));
    }

    @return $css;
}

// -----------------------------------------------------------------------------
// Generate a media-query.
// @param    $min-width    A $settings key or a CSS min-width val;
// @param    …    A $settings key or a CSS max-width val;
// -----------------------------------------------------------------------------
@mixin children($media: null, $flow: null, $widths: null, $margin: null, $position: null, $padding: null) {

    // Extract the repeat scheme.
    $repeat: null;
    $valid-widths: null;

    @each $width in $widths {
        @if type-of($width) == string {
            $repeat: $width;
        } @else {
            $valid-widths: if($valid-widths, append($valid-widths, $width), $width);
        }
    }
    $widths: $valid-widths;

    // Iterate over $widths.
    $items: length($widths);

    @for $item from 1 through $items {
        // Define the default targeted child.
        $child: #{$items}n+#{$item};
        @if $repeat == "no-repeat" {
            $child: #{$item};
        } @else if $repeat == "repeat-last" {
            $child: if($item != $items, #{$item}, n+#{$item});
        }

        > :nth-child(#{$child}) {
            @include item($media, $flow, nth($widths, $item), $margin, $position, $padding) {
                @content;
            }
        }
    }
}

// -----------------------------------------------------------------------------
// 5. Functions
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Return a map of gap vals from the $gap mixin argument
// to be used as margins and/or paddings.
// @param     $base-y   The default val for vertival gaps;
// @param     $base-x   The default val for horizontal gaps;
// @param     $val     Mixin argument;
// @return    $vals    Map of gap vals:
//                         $vals: (
//                             "global": …, <- optional key for shorthand
//                             "top": …,
//                             "right": …,
//                             "bottom": …,
//                             "left": …
//                          );
// @see       _mixins.scss.
// -----------------------------------------------------------------------------
@function gap($base-y, $base-x, $gap: null) {

    // Shorten $gap list if possible.
    @if type-of($gap) == list {
        @if length($gap) == 4 {
            @if nth($gap, 1) == nth($gap, 3) and nth($gap, 2) == nth($gap, 4)  {
                @if nth($gap, 1) == nth($gap, 2) {
                    $gap: nth($gap, 1);
                } @else {
                    $gap: nth($gap, 1) nth($gap, 2);
                }
            }
        }
        @if length($gap) == 2 {
            @if not nth($gap, 1) or not nth($gap, 2) {
            // A list of two vals can't be used as is if one of the val is false.
                $gap: nth($gap, 1) nth($gap, 2) nth($gap, 1) nth($gap, 2);
            }
        }
    }

    $sides: "top", "right", "bottom", "left";
    $gaps: ();
    $new-gaps: ();

    // Iterate over $gap vals.
    @for $index from 1 through length($gap) {
        $val: nth($gap, $index);

        @if $val != false {

            // Get the CSS $gap-val.
            $base: if($index == 1 or $index == 3, $base-y, $base-x);
            $gap-val: gap-val($base, $val);

            // Build the map.
            @if type-of($gap) == list {

                @if length($gap) == 2 {
                    $global: null;
                    @if not map-has-key($gaps, "global") {
                        // Set the first shorthand val…
                        $global: $gap-val;
                    } @else {
                        // …or append the second shorthand val.
                        $global: map-get($gaps, "global");
                        @if $global == $gap-val {
                            $global: $gap-val;
                        } @else {
                            $global: $global $gap-val;
                        }
                    }
                    $new-gaps: (
                        #{nth($sides, $index)}: $gap-val,
                        #{nth($sides, $index + 2)}: $gap-val,
                        "global": $global
                    );
                } @else {
                    $new-gaps: (
                        #{nth($sides, $index)}: $gap-val
                    );
                }
                // Merge existing vals with new ones.
                $gaps: map-merge($gaps, $new-gaps);

            } @else {
                @each $side in $sides {
                    $base: if($side == "top" or $side == "bottom", $base-y, $base-x);
                    $val-y: gap-val($base-y, $val);
                    $val-x: gap-val($base-x, $val);
                    $global: if($val-y == $val-x, $val-y, $val-y $val-x);
                    $new-gaps: (
                        #{$side}: gap-val($base, $val),
                        "global": $global
                    );
                    // Merge existing vals with new ones.
                    $gaps: map-merge($gaps, $new-gaps);
                }
            }
        }
    }

    @return $gaps;
}

// -----------------------------------------------------------------------------
// Return a css val from a $gap mixin argument
// val to be used as a margin and/or padding val.
// @param     $base       A CSS val used a calculation base when needed;
// @param     $val        A $gap val;
// @return    $gap        A CSS margin/padding val.
// @see       @function gap()
// -----------------------------------------------------------------------------
@function gap-val($base, $val) {
    $gap: null;

    @if $val == true {
        // Use the $base val.
        $gap: $base;
    } @else if $val == "nested" {
        // Use $base as a negative val.
        $gap: (-$base);
    } @else if type-of($val) == number and unitless($val) {
        // Use a factor to multiply the $base val.
        $gap: if($val == 0, $val, $val * $base);
    } @else {
        // Ignore $base; use a custom gap val.
        $gap: $val;
    }

    @return $gap;
}

// -----------------------------------------------------------------------------
// Atlterate margins depending of the $position val.
// @param     $gaps        Map returned by gap(),
// @param     $position    Mixin argument
// @return    $gaps        Alterated map
// @see       @function item()
// -----------------------------------------------------------------------------
@function position($gaps, $position) {
    $position-side: null;
    $val: null;
    $new-gaps: null;

    @if type-of($position) == number {
    // $position is a number; use it to alterate the left margin.

        // Prepare $position to be added, or soustracted if negative.
        $operator: if($position == abs($position), "+", "-");
        $position: percentage(abs($position));
        $position-side: "left";
        $margin: map-get($gaps, "left");

        @if $margin and $margin != 0 {
            $val: calc(#{$margin} #{$operator} #{$position});
        } @else {
            $val: #{$operator}$position;
        }

    } @else {
    // $position is not a number; use 'auto' to push, pull or center.
        @if $position == "pull" {
            $position-side: "right";
        } @else if $position == "push" {
            $position-side: "left";
        } @else if $position == "center" {
            $position-side: "right" "left";
        }
        $val: auto;
    }

    @each $side in $position-side {
        $new-gaps: (#{$side}: #{$val});
        $gaps: map-remove($gaps, $side);
        $gaps: map-merge($gaps, $new-gaps);
    }

    @if map-has-key($gaps, "global") {
        // Remove the global gap val(s).
        $global: map-get($gaps, "global");
        $gaps: map-remove($gaps, "global");
        @if $position == "center" {
            // Reset the global $gaps key using 'auto' for right and left margins.
            @if type-of($global) == list {
                $new-gaps: ("global": nth($global, 1) #{$val});
            } @else {
                $new-gaps: ("global": #{$val});
            }
            $gaps: map-merge($gaps, $new-gaps);
        }
    }

    @return $gaps;
}

// -----------------------------------------------------------------------------
// Return a list of media-queries in use in for item mixin as $settings keys.
// @param     $from            $settings key used as the min-width screen size;
// @param     $to              $settings key used as the max-width screen size;
// @return    $missing-bpts    A list brekpoints as set in the $settings map.
// @see       @mixin item()
// -----------------------------------------------------------------------------
@function bpts($from: null, $to: null) {
    $from-index: if($from, index($bpts, $from), 1);
    $to-index: if($to, index($bpts, $to) - 1, length($bpts));

    $missing-bpts: null;
    @if $to-index - $from-index >= 0 {
        @for $index from $from-index through $to-index {
            $bpt: nth($bpts, $index);
            @if $missing-bpts {
                $missing-bpts: append($missing-bpts, $bpt);
            } @else {
                $missing-bpts: $bpt;
            }
        }
    }

    @return $missing-bpts;
}
